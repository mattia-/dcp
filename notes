1) Why do we need a clone() method in the AbstractDifferentialProblemHerarchy?
    Because we have a stored the solver through a unique_ptr in LinearDifferentialProblem, and the copy constructor 
    is implicitly deleted because there is no unique_ptr copy constructor

2) So why did we put a unique_ptr to the solver instead of a shared_ptr in LinearDifferentialProblem?
    Because we want it to be unique. After all, what would be the sense of having a shared_ptr and then call the copy
    constructor WHICH WILL ONLY CREATE A POINTER THAT SHARES SOLVER OWNERSHIP IN THE NEW OBJECT!!!

3) And what about NonlinearDifferentialProblem? There is no unique_ptr there, so there is no need for cloning ()
    There is, since we want a unique interface for all the hierarchy

4) Why did we template-ized ObjectiveFunctional over the gradient type too?
    Because we need to know what type the gradient is in order to instantiate the right object. Otherwise we can only
    do:
        gradient_ = new DCP::VariableExpression (gradient);

    and this would leave us with the error:
        *** Error:   Unable to evaluate expression.
        *** Reason:  Missing eval() function (must be overloaded).
        *** Where:   This error was encountered inside VariableExpression.cpp.

    obviously, since gradient IS of type VariableExpression and not of any derived type.
    We do not want to define a clone () method either, since it is not declared in the base class dolfin::Expression 
    and more importantly WE WOULD FORCE THE USER TO OVERRIDE SUCH METHOD, SINCE THE RETURN TYPE WOULD HAVE TO CHANGE
