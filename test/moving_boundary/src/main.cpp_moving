/* 
 *  Copyright (C) 2014, Mattia Tamellini, mattia.tamellini@gmail.com
 * 
 *  This file is part of the DCP library
 *   
 *   The DCP library is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   The DCP library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with the DCP library.  If not, see <http://www.gnu.org/licenses/>. 
 */ 

#include <iostream>
#include <string>
#include <dolfin.h>
#include <dcp/differential_problems/differential_problems.h>
#include "heateq.h"
#include "heateqOld.h"
#include "GetPot.h"
#include "mainEnergyForms.h"
#include "MeshManager.h"
#include "MovingLinearProblem.h"
#include "MovingTimeDependentProblem.h"
#include "laplaceALE.h"

namespace heateq
{
    class DirichletBoundary : public dolfin::SubDomain
    {
        bool inside (const dolfin::Array<double>& x, bool on_boundary) const
        {
            //return dolfin::near (x[1], 0) && on_boundary;
            return (! dolfin::near (x[1], 27.2)) && on_boundary;
        } 
    };
    
    class NeumannBoundary : public dolfin::SubDomain
    {
        bool inside (const dolfin::Array<double>& x, bool on_boundary) const
        {
            return false;
        } 
    };
    
    class PenaltyBoundary : public dolfin::SubDomain
    {
        bool inside (const dolfin::Array<double>& x, bool on_boundary) const
        {
            return (dolfin::near (x[1], 1) && on_boundary);
        }
    };
    
    class DatumExpr : public dolfin::Expression
    {
        void eval(dolfin::Array<double>& values, const dolfin::Array<double>& x) const
        {
            values[0] = 1;//sin(9.42*x[0])*cos(x[1]);
        }
    };

    class ExprVec : public dolfin::Expression
    {
        void eval(dolfin::Array<double>& values, const dolfin::Array<double>& x) const
        {
            values[0] = x[0]*x[1]*x[1];
            values[1] = exp(0.5*x[0])*x[1];
        }

        std::size_t value_rank() const
        {
          return 1;
        }

        std::size_t value_dimension(std::size_t i) const
        {
          return 2;
        }
    };
}

GetPot inputData;

ProblemData problemData;

int main (int argc, char* argv[])
{
    // read data from file
    GetPot cmmLine (argc, argv);
    const std::string inputFileName = cmmLine.follow ("input.txt", 2, "-f", "--file");
    dolfin::info ("Reading input from file " + inputFileName);
    GetPot tmpGP (inputFileName.c_str());
    inputData = tmpGP;

    problemData.lx = (inputData("lx", 0.92e-3)); problemData.ly = (inputData("ly", problemData.lx));
    problemData.nx = (inputData("nx", 16)); problemData.ny = (inputData("ny", 32));
    problemData.dt = (inputData("dt", 0.0)); double t0 (inputData("t0", 0.0)), T  (inputData("T", t0));
    problemData.nu = (inputData("nu", 1.0)); double rhsvalue (inputData("f", 1.0));;
problemData.fileFrequency = inputData ("fileFrequency", 1);

 		dolfin::init(argc, argv);

    // create mesh and finite element space 
    dolfin::info ("Create mesh and finite element space...");
 		dolfin::RectangleMesh mesh (0,0, problemData.lx,problemData.ly, problemData.nx,problemData.ny);
    heateq::NeumannBoundary neumannBoundary;
    dolfin::FacetFunction<std::size_t> meshFacets (mesh);
    meshFacets.set_all (0);
    neumannBoundary.mark (meshFacets, 1);
    heateq::PenaltyBoundary penaltyBoundary;
    penaltyBoundary.mark (meshFacets, 2);

    laplaceALE::FunctionSpace W (mesh);
    dcp::LinearProblem <laplaceALE::BilinearForm, laplaceALE::LinearForm> aleProblem (dolfin::reference_to_no_delete_pointer (W));
    dolfin::Constant uno (1.0), zero (0.0), penalty (1e20);
    aleProblem.setCoefficient ("bilinear_form",dolfin::reference_to_no_delete_pointer(uno),"k");
    //aleProblem.setCoefficient ("bilinear_form",dolfin::reference_to_no_delete_pointer(zero),"k");
    aleProblem.setCoefficient ("bilinear_form",dolfin::reference_to_no_delete_pointer(penalty),"penalty");
    aleProblem.setCoefficient ("linear_form",dolfin::reference_to_no_delete_pointer(uno),"k");
    //aleProblem.setCoefficient ("linear_form",dolfin::reference_to_no_delete_pointer(zero),"k");
    aleProblem.setCoefficient ("linear_form",dolfin::reference_to_no_delete_pointer(zero),"f");
    aleProblem.setCoefficient ("linear_form",dolfin::reference_to_no_delete_pointer(zero),"g");
    aleProblem.setCoefficient ("linear_form",dolfin::reference_to_no_delete_pointer(penalty),"penalty");
		aleProblem.setIntegrationSubdomain ("bilinear_form", dolfin::reference_to_no_delete_pointer(meshFacets), dcp::SubdomainType::BOUNDARY_FACETS);
		aleProblem.setIntegrationSubdomain ("linear_form", dolfin::reference_to_no_delete_pointer(meshFacets), dcp::SubdomainType::BOUNDARY_FACETS);
	  BottomBd bottomBoundary;
    dolfin::DirichletBC dirBCbottom (W, zero, bottomBoundary, "geometric");
std::unordered_map<std::size_t, double> bdval;
dirBCbottom.get_boundary_values(bdval);
    aleProblem.addDirichletBC (dirBCbottom, std::string("bottom"));
 		MeshManager<> meshManager (dolfin::reference_to_no_delete_pointer (mesh),
															dolfin::reference_to_no_delete_pointer (meshFacets),
                              dolfin::reference_to_no_delete_pointer (aleProblem),
                              0);//4plot//,
/* 		MeshManager<> meshManager (dolfin::reference_to_no_delete_pointer (mesh),
															dolfin::reference_to_no_delete_pointer (meshFacets),
                              0);*/
    heateq::FunctionSpace V (* meshManager.mesh ());
    
    // define problem
    dolfin::info ("Define the time stepping problem...");
    //dcp::LinearProblem <heateq::BilinearForm, heateq::LinearForm> heatStep (dolfin::reference_to_no_delete_pointer (V));
    Ivan::MovingLinearProblem <heateq::FunctionSpace, heateq::FunctionSpace, heateq::BilinearForm, heateq::LinearForm, heateqOld::LinearForm, heateqOld::LinearForm> heatStep (dolfin::reference_to_no_delete_pointer (V),{});

		dolfin::LinearSolver linear_solver;
		heatStep.setLinearSolver (dolfin::reference_to_no_delete_pointer(linear_solver));
    Ivan::MovingTimeDependentProblem heatEquation (dolfin::reference_to_no_delete_pointer (meshManager),
             dolfin::reference_to_no_delete_pointer (heatStep),
    //dcp::TimeDependentProblem heatEquation (dolfin::reference_to_no_delete_pointer (heatStep),
                                            t0, problemData.dt, T,
                                            {"bilinear_form", "linear_form"},
                                            {"previous_form", "additional_form"},
                                            {});

    // define coefficients
    dolfin::info ("Define the problem's coefficients...");
    dolfin::Constant nu (problemData.nu);
//    dolfin::Constant f (rhsvalue);
    dolfin::Function f (V);
    f = (heateq::ExprVec());
    dolfin::Constant g (1.0);
    dolfin::Constant h (0.0, 0.0);
    dolfin::Constant dt (problemData.dt);
    heateq::LinearForm::CoefficientSpace_datum datumSpace (mesh);
    dolfin::Function datum (datumSpace);
    datum = (heateq::ExprVec());
    dolfin::info ("Set the problem's coefficients...");
    heatEquation.setCoefficient ("bilinear_form", dolfin::reference_to_no_delete_pointer (nu), "nu");
    heatEquation.setCoefficient ("linear_form", dolfin::reference_to_no_delete_pointer (f), "f");
    heatEquation.setCoefficient ("linear_form", dolfin::reference_to_no_delete_pointer (g), "g");
    heatEquation.setCoefficient ("linear_form", dolfin::reference_to_no_delete_pointer (datum), "datum");


    // define dirichlet boundary conditions 
    dolfin::info ("Define the problem's Dirichlet boundary conditions...");
    heateq::DirichletBoundary dirichletBoundary;
    heatEquation.addDirichletBC (h, dirichletBoundary);
    
    // define neumann boundary conditions 
    dolfin::info ("Define the problem's Neumann boundary conditions...");
    heatEquation.setIntegrationSubdomain ("linear_form", 
                                          dolfin::reference_to_no_delete_pointer (meshFacets), 
                                          dcp::SubdomainType::BOUNDARY_FACETS);
    heatEquation.setIntegrationSubdomain ("bilinear_form", 
                                          dolfin::reference_to_no_delete_pointer (meshFacets), 
                                          dcp::SubdomainType::BOUNDARY_FACETS);
    
    // solve problem
    dolfin::info ("Solve the problem...");
//    heatEquation.parameters["pause"] = true;
    heatEquation.solve ();
    
    // plots
    dolfin::plot (mesh);
    heatEquation.plotSolution ();

    dolfin::interactive ();
    
    auto sols (heatEquation.solutions ());
    std::vector<double> kinEnval (sols.size()-1), kinEnOldval (kinEnval.size()), viscPowval (kinEnval.size()), discrval (kinEnval.size()), rhsval (kinEnval.size()), balance (kinEnval.size());
    std::vector<dolfin::Form *> depOnSol, depOnPrev;
    mainEnergyForms::Form_kinEn kinEnForm (mesh);
    kinEnForm.set_coefficient ("dt", dolfin::reference_to_no_delete_pointer (dt));
    depOnSol.push_back (& kinEnForm);
    mainEnergyForms::Form_kinEnOld kinEnOldForm (mesh);
    kinEnOldForm.set_coefficient ("dt", dolfin::reference_to_no_delete_pointer (dt));
    depOnOld.push_back (& kinEnOldForm);
    mainEnergyForms::Form_viscPow viscPowForm (mesh);
    viscPowForm.set_coefficient ("nu", dolfin::reference_to_no_delete_pointer (nu));
    depOnSol.push_back (& viscPowForm);
    mainEnergyForms::Form_discr discrForm (mesh);
    discrForm.set_coefficient ("dt", dolfin::reference_to_no_delete_pointer (dt));
    depOnSol.push_back (& discrForm);
    depOnPrev.push_back (& discrForm);
    mainEnergyForms::Form_rhs rhsForm (mesh);
    rhsForm.set_coefficient ("f", dolfin::reference_to_no_delete_pointer (f));
    depOnSol.push_back (& rhsForm);

    std::cerr << "kinEn, kinEnOld, viscPow, discr, rhs, balance" << std::endl;
    for (std::size_t i (0); i!=sols.size()-1; ++i)
    {
        for (auto form : depOnSol)
            form -> set_coefficient ("u", dolfin::reference_to_no_delete_pointer (sols[i+1].second));
        for (auto form : depOnPrev)
            form -> set_coefficient ("u_old", dolfin::reference_to_no_delete_pointer (sols[i].second));
        std::cerr << std::setprecision(16) << (kinEnval[i] = dolfin::assemble (kinEnForm)) << ", ";
        std::cerr << std::setprecision(16) << (kinEnOldval[i] = dolfin::assemble (kinEnOldForm)) << ",";
        std::cerr << std::setprecision(16) << (viscPowval[i] = dolfin::assemble (viscPowForm)) << ", ";
        std::cerr << std::setprecision(16) << (discrval[i] = dolfin::assemble (discrForm)) << ", ";
        std::cerr << std::setprecision(16) << (rhsval[i] = dolfin::assemble (rhsForm)) << ", ";
        std::cerr << std::setprecision(16) << (balance[i] = kinEnval[i]-kinEnOldval[i] + viscPowval[i] + discrval[i] - rhsval[i] + 0.5) << std::endl;
    }

    return 0;
}
