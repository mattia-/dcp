/* 
 *  Copyright (C) 2014, Mattia Tamellini, mattia.tamellini@gmail.com
 * 
 *  This file is part of the DCP library
 *   
 *   The DCP library is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   The DCP library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with the DCP library.  If not, see <http://www.gnu.org/licenses/>. 
 */ 

// This code conforms with the UFC specification version 2.3.0
// and was automatically generated by FFC version 1.3.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   cache_dir:                      ''
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   True
//   format:                         'dolfin'
//   log_level:                      20
//   log_prefix:                     ''
//   optimize:                       True
//   output_dir:                     '.'
//   precision:                      15
//   quadrature_degree:              'auto'
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   restrict_keyword:               ''
//   split:                          False

#ifndef __PRIMAL_H
#define __PRIMAL_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class primal_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  primal_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Real', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 0, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Reset values
    *values = 0.0;
    
    // Array of basisvalues
    double basisvalues[1] = {0.0};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s)
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
    return ;
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new primal_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class primal_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  primal_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point x in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 6; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      }// end loop over 's'
    }// end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[4];
    for (unsigned int r = 0; r < 4; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new primal_finite_element_1();
  }

};

/// This class defines the interface for a finite element.

class primal_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  primal_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 2, 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point x in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 12; r++)
    {
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = 0.0;
      }// end loop over 's'
    }// end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[8];
    for (unsigned int r = 0; r < 8; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_finite_element_1();
        break;
      }
    case 1:
      {
        return new primal_finite_element_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new primal_finite_element_2();
  }

};

/// This class defines the interface for a finite element.

class primal_finite_element_3: public ufc::finite_element
{
public:

  /// Constructor
  primal_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_finite_element_3()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point x in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[2][1];
    for (unsigned int row = 0; row < 2; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[2][2];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 3; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      }// end loop over 's'
    }// end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[2];
    for (unsigned int r = 0; r < 2; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new primal_finite_element_3();
  }

};

/// This class defines the interface for a finite element.

class primal_finite_element_4: public ufc::finite_element
{
public:

  /// Constructor
  primal_finite_element_4() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_finite_element_4()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[VectorElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 2, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point x in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 15; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      }// end loop over 's'
    }// end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[12];
    for (unsigned int r = 0; r < 12; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_finite_element_2();
        break;
      }
    case 1:
      {
        return new primal_finite_element_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new primal_finite_element_4();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class primal_dofmap_0: public ufc::dofmap
{
public:

  /// Constructor
  primal_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_dofmap_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Real', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 0, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 1;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = 0;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[0][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new primal_dofmap_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class primal_dofmap_1: public ufc::dofmap
{
public:

  /// Constructor
  primal_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_dofmap_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0] + num_global_entities[1];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 1;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new primal_dofmap_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class primal_dofmap_2: public ufc::dofmap
{
public:

  /// Constructor
  primal_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_dofmap_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 2, 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 2*num_global_entities[0] + 2*num_global_entities[1];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 6;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[6][0] = vertex_coordinates[0];
    dof_coordinates[6][1] = vertex_coordinates[1];
    dof_coordinates[7][0] = vertex_coordinates[2];
    dof_coordinates[7][1] = vertex_coordinates[3];
    dof_coordinates[8][0] = vertex_coordinates[4];
    dof_coordinates[8][1] = vertex_coordinates[5];
    dof_coordinates[9][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[10][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[11][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[11][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_dofmap_1();
        break;
      }
    case 1:
      {
        return new primal_dofmap_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new primal_dofmap_2();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class primal_dofmap_3: public ufc::dofmap
{
public:

  /// Constructor
  primal_dofmap_3() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_dofmap_3()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 2;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[0][0];
    dofs[1] = c.entity_indices[0][1];
    dofs[2] = c.entity_indices[0][2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new primal_dofmap_3();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class primal_dofmap_4: public ufc::dofmap
{
public:

  /// Constructor
  primal_dofmap_4() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_dofmap_4()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[VectorElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 2, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2), 'triangle_multiverse', 2, 2), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 3*num_global_entities[0] + 2*num_global_entities[1];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[12] = offset + c.entity_indices[0][0];
    dofs[13] = offset + c.entity_indices[0][1];
    dofs[14] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
      dofs[6] = 12;
      dofs[7] = 14;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
      dofs[6] = 12;
      dofs[7] = 13;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
        dofs[2] = 12;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
        dofs[2] = 13;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
        dofs[2] = 14;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[6][0] = vertex_coordinates[0];
    dof_coordinates[6][1] = vertex_coordinates[1];
    dof_coordinates[7][0] = vertex_coordinates[2];
    dof_coordinates[7][1] = vertex_coordinates[3];
    dof_coordinates[8][0] = vertex_coordinates[4];
    dof_coordinates[8][1] = vertex_coordinates[5];
    dof_coordinates[9][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[10][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[11][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[11][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[12][0] = vertex_coordinates[0];
    dof_coordinates[12][1] = vertex_coordinates[1];
    dof_coordinates[13][0] = vertex_coordinates[2];
    dof_coordinates[13][1] = vertex_coordinates[3];
    dof_coordinates[14][0] = vertex_coordinates[4];
    dof_coordinates[14][1] = vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_dofmap_2();
        break;
      }
    case 1:
      {
        return new primal_dofmap_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new primal_dofmap_4();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class primal_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  primal_cell_integral_0_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_cell_integral_0_otherwise()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell volume
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W7[7] = {0.1125, 0.0629695902724136, 0.0629695902724136, 0.0629695902724136, 0.0661970763942531, 0.0661970763942531, 0.0661970763942531};
    // Quadrature points on the UFC reference element: (0.333333333333333, 0.333333333333333), (0.797426985353087, 0.101286507323456), (0.101286507323456, 0.797426985353087), (0.101286507323456, 0.101286507323456), (0.0597158717897698, 0.470142064105115), (0.470142064105115, 0.0597158717897698), (0.470142064105115, 0.470142064105115)
    
    // Value of basis functions at quadrature points.
    static const double FE0_C0[7][6] = \
    {{-0.111111111111111, -0.111111111111111, -0.111111111111111, 0.444444444444444, 0.444444444444444, 0.444444444444444},
    {-0.0807685941918872, 0.474352608585538, -0.0807685941918871, 0.323074376767549, 0.0410358262631383, 0.323074376767549},
    {-0.0807685941918872, -0.0807685941918872, 0.474352608585538, 0.323074376767549, 0.323074376767549, 0.0410358262631383},
    {0.474352608585539, -0.0807685941918871, -0.0807685941918871, 0.0410358262631383, 0.323074376767549, 0.323074376767549},
    {-0.0280749432230786, -0.0525839011025453, -0.0280749432230788, 0.112299772892315, 0.884134241764073, 0.112299772892315},
    {-0.0280749432230787, -0.0280749432230788, -0.0525839011025453, 0.112299772892315, 0.112299772892315, 0.884134241764073},
    {-0.0525839011025454, -0.0280749432230789, -0.0280749432230788, 0.884134241764072, 0.112299772892315, 0.112299772892315}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc0[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE0_C0_D01[7][5] = \
    {{-0.333333333333333, 0.333333333333333, 1.33333333333333, 0.0, -1.33333333333333},
    {0.594853970706175, -0.594853970706175, 3.18970794141235, 0.0, -3.18970794141235},
    {0.594853970706174, 2.18970794141235, 0.405146029293824, -2.78456191211852, -0.405146029293825},
    {-2.18970794141235, -0.594853970706175, 0.405146029293824, 2.78456191211852, -0.405146029293825},
    {-0.880568256420461, 0.88056825642046, 0.238863487159078, 0.0, -0.238863487159078},
    {-0.88056825642046, -0.76113651284092, 1.88056825642046, 1.64170476926138, -1.88056825642046},
    {0.761136512840921, 0.88056825642046, 1.88056825642046, -1.64170476926138, -1.88056825642046}};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 2, 3, 4, 5};
    
    static const double FE0_C0_D10[7][5] = \
    {{-0.333333333333333, 0.333333333333333, 1.33333333333333, -1.33333333333333, 0.0},
    {0.594853970706174, 2.18970794141235, 0.405146029293824, -0.405146029293824, -2.78456191211852},
    {0.594853970706175, -0.594853970706175, 3.18970794141235, -3.18970794141235, 0.0},
    {-2.18970794141235, -0.594853970706175, 0.405146029293824, -0.405146029293824, 2.78456191211852},
    {-0.880568256420461, -0.761136512840922, 1.88056825642046, -1.88056825642046, 1.64170476926138},
    {-0.88056825642046, 0.880568256420461, 0.238863487159078, -0.238863487159078, 0.0},
    {0.761136512840921, 0.88056825642046, 1.88056825642046, -1.88056825642046, -1.64170476926138}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[5] = {0, 1, 3, 4, 5};
    
    static const double FE0_C2[7][3] = \
    {{0.333333333333333, 0.333333333333333, 0.333333333333333},
    {0.101286507323456, 0.797426985353087, 0.101286507323456},
    {0.101286507323457, 0.101286507323456, 0.797426985353087},
    {0.797426985353087, 0.101286507323456, 0.101286507323456},
    {0.470142064105115, 0.0597158717897698, 0.470142064105115},
    {0.470142064105115, 0.470142064105115, 0.0597158717897697},
    {0.0597158717897699, 0.470142064105115, 0.470142064105115}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] = K[0]*det;
    G[1] = K[2]*det;
    G[2] = K[1]*det;
    G[3] = K[3]*det;
    G[4] =  - K[2]*det;
    G[5] = det*w[1][0]*(K[0]*K[2] + K[1]*K[3]);
    G[6] = det*w[1][0]*(K[2]*K[2] + K[3]*K[3]);
    G[7] =  - K[0]*det;
    G[8] = det*w[1][0]*(K[0]*K[0] + K[1]*K[1]);
    G[9] =  - K[3]*det;
    G[10] =  - K[1]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1344
    for (unsigned int ip = 0; ip < 7; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F0 += FE0_C2[ip][r]*w[0][nzc6[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F1 += FE0_C0_D10[ip][r]*w[0][nzc2[r]];
        F2 += FE0_C0_D01[ip][r]*w[0][nzc1[r]];
        F3 += FE0_C0_D10[ip][r]*w[0][nzc5[r]];
        F4 += FE0_C0_D01[ip][r]*w[0][nzc4[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 6; r++)
      {
        F5 += FE0_C0[ip][r]*w[0][nzc0[r]];
        F6 += FE0_C0[ip][r]*w[0][nzc3[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 52
      double I[7];
      // Number of operations: 8
      I[0] = W7[ip]*(F1*G[0] + F2*G[1] + F3*G[2] + F4*G[3]);
      
      // Number of operations: 6
      I[1] = W7[ip]*(F0*G[4] + F1*G[5] + F2*G[6]);
      
      // Number of operations: 6
      I[2] = W7[ip]*(F0*G[7] + F1*G[8] + F2*G[5]);
      
      // Number of operations: 6
      I[3] = W7[ip]*(F0*G[9] + F3*G[5] + F4*G[6]);
      
      // Number of operations: 6
      I[4] = W7[ip]*(F0*G[10] + F3*G[8] + F4*G[5]);
      
      // Number of operations: 10
      I[5] = W7[ip]*(F5*(F1*G[0] + F2*G[1]) + F6*(F1*G[2] + F2*G[3]));
      
      // Number of operations: 10
      I[6] = W7[ip]*(F5*(F3*G[0] + F4*G[1]) + F6*(F3*G[2] + F4*G[3]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE0_C2[ip][j]*I[0];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE0_C0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE0_C0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE0_C0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE0_C0_D10[ip][j]*I[4];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE0_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE0_C0[ip][j]*I[6];
      }// end loop over 'j'
    }// end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class primal_cell_integral_1_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  primal_cell_integral_1_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_cell_integral_1_otherwise()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      3
    // Number of operations (multiply-add pairs) for geometry tensor:    172
    // Number of operations (multiply-add pairs) for tensor contraction: 3272
    // Total number of operations (multiply-add pairs):                  3447
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*K[0]*(1.0);
    const double G0_1 = det*K[2]*(1.0);
    const double G1_0 = det*K[1]*(1.0);
    const double G1_1 = det*K[3]*(1.0);
    const double G2_0 = det*K[0]*(1.0);
    const double G2_1 = det*K[2]*(1.0);
    const double G3_0 = det*K[1]*(1.0);
    const double G3_1 = det*K[3]*(1.0);
    const double G4_0_0_0 = det*w[1][0]*K[0]*K[0]*(1.0);
    const double G4_0_0_1 = det*w[1][0]*K[0]*K[2]*(1.0);
    const double G4_0_1_0 = det*w[1][0]*K[2]*K[0]*(1.0);
    const double G4_0_1_1 = det*w[1][0]*K[2]*K[2]*(1.0);
    const double G5_0_0_0 = det*w[1][0]*K[0]*K[0]*(1.0);
    const double G5_0_0_1 = det*w[1][0]*K[0]*K[2]*(1.0);
    const double G5_0_1_0 = det*w[1][0]*K[2]*K[0]*(1.0);
    const double G5_0_1_1 = det*w[1][0]*K[2]*K[2]*(1.0);
    const double G6_0_0_0 = det*w[1][0]*K[1]*K[1]*(1.0);
    const double G6_0_0_1 = det*w[1][0]*K[1]*K[3]*(1.0);
    const double G6_0_1_0 = det*w[1][0]*K[3]*K[1]*(1.0);
    const double G6_0_1_1 = det*w[1][0]*K[3]*K[3]*(1.0);
    const double G7_0_0_0 = det*w[1][0]*K[1]*K[1]*(1.0);
    const double G7_0_0_1 = det*w[1][0]*K[1]*K[3]*(1.0);
    const double G7_0_1_0 = det*w[1][0]*K[3]*K[1]*(1.0);
    const double G7_0_1_1 = det*w[1][0]*K[3]*K[3]*(1.0);
    const double G8_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G8_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G8_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G8_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G8_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G8_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G8_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G8_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G8_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G8_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G9_0_0 = det*w[0][0]*K[1]*(1.0);
    const double G9_0_1 = det*w[0][0]*K[3]*(1.0);
    const double G9_1_0 = det*w[0][1]*K[1]*(1.0);
    const double G9_2_1 = det*w[0][2]*K[3]*(1.0);
    const double G9_3_0 = det*w[0][3]*K[1]*(1.0);
    const double G9_3_1 = det*w[0][3]*K[3]*(1.0);
    const double G9_4_0 = det*w[0][4]*K[1]*(1.0);
    const double G9_4_1 = det*w[0][4]*K[3]*(1.0);
    const double G9_5_0 = det*w[0][5]*K[1]*(1.0);
    const double G9_5_1 = det*w[0][5]*K[3]*(1.0);
    const double G10_6_0 = det*w[0][6]*K[0]*(1.0);
    const double G10_6_1 = det*w[0][6]*K[2]*(1.0);
    const double G10_7_0 = det*w[0][7]*K[0]*(1.0);
    const double G10_8_1 = det*w[0][8]*K[2]*(1.0);
    const double G10_9_0 = det*w[0][9]*K[0]*(1.0);
    const double G10_9_1 = det*w[0][9]*K[2]*(1.0);
    const double G10_10_0 = det*w[0][10]*K[0]*(1.0);
    const double G10_10_1 = det*w[0][10]*K[2]*(1.0);
    const double G10_11_0 = det*w[0][11]*K[0]*(1.0);
    const double G10_11_1 = det*w[0][11]*K[2]*(1.0);
    const double G11_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G11_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G11_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G11_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G11_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G11_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G11_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G11_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G11_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G11_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G12_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G12_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G12_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G12_1_1 = det*w[0][1]*K[2]*(1.0);
    const double G12_2_0 = det*w[0][2]*K[0]*(1.0);
    const double G12_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G12_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G12_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G12_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G12_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G12_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G12_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G13_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G13_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G13_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G13_7_1 = det*w[0][7]*K[3]*(1.0);
    const double G13_8_0 = det*w[0][8]*K[1]*(1.0);
    const double G13_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G13_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G13_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G13_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G13_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G13_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G13_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G14_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G14_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G14_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G14_1_1 = det*w[0][1]*K[2]*(1.0);
    const double G14_2_0 = det*w[0][2]*K[0]*(1.0);
    const double G14_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G14_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G14_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G14_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G14_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G14_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G14_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G15_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G15_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G15_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G15_7_1 = det*w[0][7]*K[3]*(1.0);
    const double G15_8_0 = det*w[0][8]*K[1]*(1.0);
    const double G15_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G15_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G15_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G15_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G15_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G15_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G15_11_1 = det*w[0][11]*K[3]*(1.0);
    
    // Compute element tensor
    double A0[225];
    A0[108] = 0.0;
    A0[99] = 0.0;
    A0[181] = 0.0;
    A0[176] = 0.0;
    A0[117] = 0.0;
    A0[214] = 0.0;
    A0[199] = 0.0;
    A0[192] = 0.0;
    A0[7] = 0.0;
    A0[21] = 0.0;
    A0[10] = 0.0;
    A0[52] = 0.0;
    A0[35] = 0.0;
    A0[26] = 0.0;
    A0[125] = 0.0;
    A0[83] = 0.0;
    A0[60] = 0.0;
    A0[158] = 0.0;
    A0[135] = 0.0;
    A0[97] = 0.0;
    A0[80] = 0.0;
    A0[170] = 0.0;
    A0[157] = 0.0;
    A0[111] = 0.0;
    A0[100] = 0.0;
    A0[186] = 0.0;
    A0[211] = 0.0;
    A0[202] = 0.0;
    A0[4] = 0.0;
    A0[16] = 0.0;
    A0[70] = 0.0;
    A0[47] = 0.0;
    A0[36] = 0.0;
    A0[149] = 0.0;
    A0[122] = 0.0;
    A0[86] = 0.0;
    A0[65] = 0.0;
    A0[163] = 0.0;
    A0[138] = 0.0;
    A0[90] = 0.0;
    A0[165] = 0.0;
    A0[110] = 0.0;
    A0[191] = 0.0;
    A0[212] = 0.0;
    A0[205] = 0.0;
    A0[1] = 0.0;
    A0[27] = 0.0;
    A0[132] = 0.0;
    A0[46] = 0.0;
    A0[41] = 0.0;
    A0[144] = 0.0;
    A0[89] = 0.166666666666667*G0_1;
    A0[57] = -A0[89] - 0.166666666666667*G0_0;
    A0[164] = 0.0;
    A0[103] = 0.0;
    A0[113] = 0.0;
    A0[218] = 0.0;
    A0[195] = 0.0;
    A0[188] = 0.0;
    A0[208] = 0.0;
    A0[14] = 0.0;
    A0[56] = 0.0;
    A0[31] = 0.0;
    A0[129] = 0.0;
    A0[72] = -A0[89] + 0.166666666666667*G0_0;
    A0[42] = 0.0;
    A0[139] = 0.0;
    A0[76] = 0.0;
    A0[153] = 0.0;
    A0[107] = 0.0;
    A0[104] = 0.0;
    A0[182] = 0.0;
    A0[175] = 0.0;
    A0[215] = 0.0;
    A0[198] = 0.0;
    A0[193] = 0.0;
    A0[20] = 0.0;
    A0[11] = 0.0;
    A0[51] = 0.0;
    A0[32] = 0.0;
    A0[25] = 0.0;
    A0[126] = 0.0;
    A0[61] = 0.0;
    A0[159] = 0.0;
    A0[142] = 0.0;
    A0[94] = 0.0;
    A0[79] = 0.0;
    A0[169] = 0.0;
    A0[154] = 0.0;
    A0[106] = 0.0;
    A0[101] = 0.0;
    A0[187] = 0.0;
    A0[174] = 0.0;
    A0[216] = 0.0;
    A0[201] = 0.0;
    A0[5] = 0.0;
    A0[15] = 0.0;
    A0[8] = 0.0;
    A0[71] = 0.0;
    A0[50] = 0.0;
    A0[37] = 0.0;
    A0[148] = 0.0;
    A0[123] = 0.0;
    A0[85] = 0.0;
    A0[66] = 0.0;
    A0[160] = 0.0;
    A0[137] = 0.0;
    A0[91] = 0.0;
    A0[82] = 0.0;
    A0[168] = 0.0;
    A0[109] = 0.0;
    A0[222] = 0.0;
    A0[184] = 0.0;
    A0[213] = 0.0;
    A0[204] = 0.0;
    A0[2] = 0.0;
    A0[18] = 0.0;
    A0[133] = 0.0;
    A0[68] = 0.0;
    A0[45] = 0.0;
    A0[38] = 0.0;
    A0[143] = 0.0;
    A0[120] = 0.0;
    A0[88] = -A0[57] + 0.166666666666667*G0_1;
    A0[92] = 0.0;
    A0[179] = 0.0;
    A0[116] = 0.0;
    A0[219] = 0.0;
    A0[189] = 0.0;
    A0[207] = 0.0;
    A0[55] = 0.0;
    A0[29] = 0.0;
    A0[130] = 0.0;
    A0[73] = 0.166666666666667*G0_0;
    A0[43] = 0.0;
    A0[146] = 0.0;
    A0[75] = 0.0;
    A0[150] = 0.0;
    A0[183] = 0.0;
    A0[178] = 0.0;
    A0[119] = 0.0;
    A0[220] = 0.0;
    A0[197] = 0.0;
    A0[194] = 0.0;
    A0[19] = 0.0;
    A0[12] = -A0[57];
    A0[54] = 0.0;
    A0[33] = 0.0;
    A0[24] = 0.0;
    A0[127] = 0.0;
    A0[62] = 0.0;
    A0[44] = -A0[89];
    A0[141] = 0.0;
    A0[95] = 0.0;
    A0[78] = 0.0;
    A0[172] = 0.0;
    A0[155] = 0.0;
    A0[105] = 0.0;
    A0[98] = 0.0;
    A0[180] = 0.0;
    A0[173] = 0.0;
    A0[118] = 0.0;
    A0[217] = 0.0;
    A0[200] = 0.0;
    A0[6] = 0.0;
    A0[22] = 0.0;
    A0[9] = 0.0;
    A0[49] = 0.0;
    A0[34] = 0.0;
    A0[147] = 0.0;
    A0[124] = 0.0;
    A0[84] = 0.0;
    A0[67] = 0.0;
    A0[161] = 0.0;
    A0[136] = 0.0;
    A0[96] = 0.0;
    A0[81] = 0.0;
    A0[167] = 0.0;
    A0[156] = 0.0;
    A0[112] = 0.0;
    A0[223] = 0.0;
    A0[185] = 0.0;
    A0[210] = 0.0;
    A0[203] = 0.0;
    A0[3] = 0.0;
    A0[59] = -A0[89] - 0.333333333333333*G0_0;
    A0[17] = 0.0;
    A0[134] = 0.0;
    A0[69] = 0.0;
    A0[48] = 0.0;
    A0[39] = 0.0;
    A0[121] = 0.0;
    A0[87] = -A0[72];
    A0[64] = 0.0;
    A0[162] = 0.0;
    A0[93] = 0.0;
    A0[166] = 0.0;
    A0[115] = 0.0;
    A0[224] = 0.0;
    A0[190] = 0.0;
    A0[206] = 0.0;
    A0[0] = 0.0;
    A0[58] = -A0[88];
    A0[28] = -A0[73];
    A0[131] = 0.0;
    A0[74] = -A0[59];
    A0[40] = 0.0;
    A0[145] = 0.0;
    A0[151] = 0.0;
    A0[102] = 0.0;
    A0[177] = 0.0;
    A0[114] = 0.0;
    A0[221] = 0.0;
    A0[196] = 0.0;
    A0[209] = 0.0;
    A0[13] = 0.0;
    A0[53] = 0.0;
    A0[30] = 0.0;
    A0[23] = 0.0;
    A0[128] = 0.0;
    A0[63] = 0.0;
    A0[140] = 0.0;
    A0[77] = 0.0;
    A0[171] = 0.0;
    A0[152] = 0.0;
    
    double A1[225];
    A1[108] = 0.0;
    A1[99] = 0.0;
    A1[181] = 0.0;
    A1[176] = 0.0;
    A1[117] = 0.0;
    A1[214] = 0.0;
    A1[199] = 0.0;
    A1[192] = 0.0;
    A1[7] = 0.0;
    A1[21] = 0.0;
    A1[10] = 0.0;
    A1[52] = 0.0;
    A1[35] = 0.0;
    A1[26] = 0.0;
    A1[125] = 0.0;
    A1[83] = 0.0;
    A1[60] = 0.0;
    A1[158] = 0.0;
    A1[135] = 0.0;
    A1[97] = 0.0;
    A1[80] = 0.0;
    A1[170] = 0.0;
    A1[157] = 0.0;
    A1[111] = 0.0;
    A1[100] = 0.0;
    A1[186] = 0.0;
    A1[211] = 0.0;
    A1[202] = 0.0;
    A1[4] = 0.0;
    A1[16] = 0.0;
    A1[70] = 0.0;
    A1[47] = 0.0;
    A1[36] = 0.0;
    A1[122] = 0.0;
    A1[86] = 0.0;
    A1[65] = 0.0;
    A1[163] = 0.166666666666667*G1_0;
    A1[138] = 0.0;
    A1[90] = 0.0;
    A1[165] = 0.0;
    A1[110] = 0.0;
    A1[191] = 0.0;
    A1[212] = 0.0;
    A1[205] = 0.0;
    A1[1] = 0.0;
    A1[57] = 0.0;
    A1[27] = 0.0;
    A1[132] = 0.0;
    A1[46] = 0.0;
    A1[41] = 0.0;
    A1[144] = 0.0;
    A1[89] = 0.0;
    A1[103] = 0.0;
    A1[113] = 0.0;
    A1[218] = 0.0;
    A1[195] = 0.0;
    A1[188] = 0.0;
    A1[208] = 0.0;
    A1[14] = 0.0;
    A1[56] = 0.0;
    A1[31] = 0.0;
    A1[129] = 0.0;
    A1[72] = 0.0;
    A1[42] = 0.0;
    A1[139] = 0.0;
    A1[76] = 0.0;
    A1[153] = 0.0;
    A1[107] = 0.0;
    A1[104] = 0.0;
    A1[182] = 0.0;
    A1[175] = 0.0;
    A1[215] = 0.0;
    A1[198] = 0.0;
    A1[193] = 0.0;
    A1[20] = 0.0;
    A1[11] = 0.0;
    A1[51] = 0.0;
    A1[32] = 0.0;
    A1[25] = 0.0;
    A1[126] = 0.0;
    A1[61] = 0.0;
    A1[159] = 0.0;
    A1[142] = 0.0;
    A1[94] = 0.0;
    A1[79] = 0.0;
    A1[169] = 0.0;
    A1[154] = 0.0;
    A1[106] = 0.0;
    A1[101] = 0.0;
    A1[187] = 0.0;
    A1[174] = 0.0;
    A1[216] = 0.0;
    A1[201] = 0.0;
    A1[5] = 0.0;
    A1[15] = 0.0;
    A1[8] = 0.0;
    A1[71] = 0.0;
    A1[50] = 0.0;
    A1[37] = 0.0;
    A1[148] = -A1[163] - 0.333333333333333*G1_1;
    A1[123] = 0.0;
    A1[85] = 0.0;
    A1[66] = 0.0;
    A1[160] = 0.0;
    A1[137] = 0.0;
    A1[91] = 0.0;
    A1[82] = 0.0;
    A1[168] = 0.0;
    A1[109] = 0.0;
    A1[222] = 0.0;
    A1[184] = 0.0;
    A1[213] = 0.0;
    A1[204] = 0.0;
    A1[2] = 0.0;
    A1[18] = 0.0;
    A1[133] = 0.0;
    A1[68] = 0.0;
    A1[45] = 0.0;
    A1[38] = 0.0;
    A1[143] = 0.0;
    A1[120] = 0.0;
    A1[88] = 0.0;
    A1[92] = 0.0;
    A1[179] = 0.166666666666667*G1_1;
    A1[149] = -A1[179] - 0.333333333333333*G1_0;
    A1[164] = -A1[149];
    A1[116] = 0.0;
    A1[219] = 0.0;
    A1[189] = 0.0;
    A1[207] = 0.0;
    A1[55] = 0.0;
    A1[29] = 0.0;
    A1[130] = 0.0;
    A1[73] = 0.0;
    A1[43] = 0.0;
    A1[146] = 0.0;
    A1[75] = 0.0;
    A1[150] = 0.0;
    A1[183] = 0.0;
    A1[178] = -A1[148];
    A1[119] = 0.0;
    A1[220] = 0.0;
    A1[197] = 0.0;
    A1[194] = 0.0;
    A1[19] = 0.0;
    A1[12] = 0.0;
    A1[54] = 0.0;
    A1[33] = 0.0;
    A1[24] = 0.0;
    A1[127] = 0.0;
    A1[62] = 0.0;
    A1[44] = 0.0;
    A1[141] = 0.0;
    A1[95] = 0.0;
    A1[78] = 0.0;
    A1[172] = 0.0;
    A1[155] = 0.0;
    A1[105] = 0.0;
    A1[98] = 0.0;
    A1[180] = 0.0;
    A1[173] = 0.0;
    A1[118] = -A1[163];
    A1[217] = 0.0;
    A1[200] = 0.0;
    A1[6] = 0.0;
    A1[22] = 0.0;
    A1[9] = 0.0;
    A1[49] = 0.0;
    A1[34] = 0.0;
    A1[147] = -A1[163] - 0.166666666666667*G1_1;
    A1[124] = 0.0;
    A1[84] = 0.0;
    A1[67] = 0.0;
    A1[161] = 0.0;
    A1[136] = 0.0;
    A1[96] = 0.0;
    A1[81] = 0.0;
    A1[167] = 0.0;
    A1[156] = 0.0;
    A1[112] = 0.0;
    A1[223] = 0.0;
    A1[185] = 0.0;
    A1[210] = 0.0;
    A1[203] = 0.0;
    A1[3] = 0.0;
    A1[59] = 0.0;
    A1[17] = 0.0;
    A1[134] = -A1[179];
    A1[69] = 0.0;
    A1[48] = 0.0;
    A1[39] = 0.0;
    A1[121] = 0.0;
    A1[87] = 0.0;
    A1[64] = 0.0;
    A1[162] = A1[163] - 0.166666666666667*G1_1;
    A1[93] = 0.0;
    A1[166] = 0.0;
    A1[115] = 0.0;
    A1[224] = 0.0;
    A1[190] = 0.0;
    A1[206] = 0.0;
    A1[0] = 0.0;
    A1[58] = 0.0;
    A1[28] = 0.0;
    A1[131] = 0.0;
    A1[74] = 0.0;
    A1[40] = 0.0;
    A1[145] = 0.0;
    A1[151] = 0.0;
    A1[102] = -A1[147];
    A1[177] = -A1[162];
    A1[114] = 0.0;
    A1[221] = 0.0;
    A1[196] = 0.0;
    A1[209] = 0.0;
    A1[13] = 0.0;
    A1[53] = 0.0;
    A1[30] = 0.0;
    A1[23] = 0.0;
    A1[128] = 0.0;
    A1[63] = 0.0;
    A1[140] = 0.0;
    A1[77] = 0.0;
    A1[171] = 0.0;
    A1[152] = 0.0;
    
    double A2[225];
    A2[108] = 0.0;
    A2[99] = 0.0;
    A2[181] = 0.0;
    A2[176] = 0.0;
    A2[117] = 0.0;
    A2[199] = -0.166666666666667*G2_0;
    A2[192] = 0.0;
    A2[7] = 0.0;
    A2[21] = 0.0;
    A2[10] = 0.0;
    A2[52] = 0.0;
    A2[35] = 0.0;
    A2[26] = 0.0;
    A2[125] = 0.0;
    A2[83] = 0.0;
    A2[60] = 0.0;
    A2[158] = 0.0;
    A2[135] = 0.0;
    A2[97] = 0.0;
    A2[80] = 0.0;
    A2[170] = 0.0;
    A2[157] = 0.0;
    A2[111] = 0.0;
    A2[100] = 0.0;
    A2[186] = 0.0;
    A2[211] = 0.0;
    A2[202] = 0.0;
    A2[4] = 0.0;
    A2[16] = 0.0;
    A2[70] = 0.0;
    A2[47] = 0.0;
    A2[36] = 0.0;
    A2[149] = 0.0;
    A2[122] = 0.0;
    A2[86] = 0.0;
    A2[65] = 0.0;
    A2[163] = 0.0;
    A2[138] = 0.0;
    A2[90] = 0.0;
    A2[165] = 0.0;
    A2[110] = 0.0;
    A2[191] = 0.0;
    A2[212] = 0.166666666666667*G2_1;
    A2[214] = -A2[212] - 0.333333333333333*G2_0;
    A2[205] = 0.0;
    A2[1] = 0.0;
    A2[57] = 0.0;
    A2[27] = 0.0;
    A2[132] = 0.0;
    A2[46] = 0.0;
    A2[41] = 0.0;
    A2[144] = 0.0;
    A2[89] = 0.0;
    A2[164] = 0.0;
    A2[103] = 0.0;
    A2[113] = 0.0;
    A2[218] = 0.0;
    A2[195] = 0.0;
    A2[188] = 0.0;
    A2[208] = 0.0;
    A2[14] = 0.0;
    A2[56] = 0.0;
    A2[31] = 0.0;
    A2[129] = 0.0;
    A2[72] = 0.0;
    A2[42] = 0.0;
    A2[139] = 0.0;
    A2[76] = 0.0;
    A2[153] = 0.0;
    A2[107] = 0.0;
    A2[104] = 0.0;
    A2[182] = 0.0;
    A2[175] = 0.0;
    A2[215] = -A2[212];
    A2[198] = -A2[199] + 0.333333333333333*G2_1;
    A2[193] = 0.0;
    A2[20] = 0.0;
    A2[11] = 0.0;
    A2[51] = 0.0;
    A2[32] = 0.0;
    A2[25] = 0.0;
    A2[126] = 0.0;
    A2[61] = 0.0;
    A2[159] = 0.0;
    A2[142] = 0.0;
    A2[94] = 0.0;
    A2[79] = 0.0;
    A2[169] = 0.0;
    A2[154] = 0.0;
    A2[106] = 0.0;
    A2[101] = 0.0;
    A2[187] = 0.0;
    A2[174] = 0.0;
    A2[216] = 0.0;
    A2[201] = 0.0;
    A2[5] = 0.0;
    A2[15] = 0.0;
    A2[8] = 0.0;
    A2[71] = 0.0;
    A2[50] = 0.0;
    A2[37] = 0.0;
    A2[148] = 0.0;
    A2[123] = 0.0;
    A2[85] = 0.0;
    A2[66] = 0.0;
    A2[160] = 0.0;
    A2[137] = 0.0;
    A2[91] = 0.0;
    A2[82] = 0.0;
    A2[168] = 0.0;
    A2[109] = 0.0;
    A2[222] = 0.0;
    A2[184] = A2[199] + 0.166666666666667*G2_1;
    A2[213] = -A2[214];
    A2[204] = 0.0;
    A2[2] = 0.0;
    A2[18] = 0.0;
    A2[133] = 0.0;
    A2[68] = 0.0;
    A2[45] = 0.0;
    A2[38] = 0.0;
    A2[143] = 0.0;
    A2[120] = 0.0;
    A2[88] = 0.0;
    A2[92] = 0.0;
    A2[179] = 0.0;
    A2[116] = 0.0;
    A2[219] = 0.0;
    A2[189] = 0.0;
    A2[207] = 0.0;
    A2[55] = 0.0;
    A2[29] = 0.0;
    A2[130] = 0.0;
    A2[73] = 0.0;
    A2[43] = 0.0;
    A2[146] = 0.0;
    A2[75] = 0.0;
    A2[150] = 0.0;
    A2[183] = -A2[199] + 0.166666666666667*G2_1;
    A2[178] = 0.0;
    A2[119] = 0.0;
    A2[220] = 0.0;
    A2[197] = 0.0;
    A2[194] = 0.0;
    A2[19] = 0.0;
    A2[12] = 0.0;
    A2[54] = 0.0;
    A2[33] = 0.0;
    A2[24] = 0.0;
    A2[127] = 0.0;
    A2[62] = 0.0;
    A2[44] = 0.0;
    A2[141] = 0.0;
    A2[95] = 0.0;
    A2[78] = 0.0;
    A2[172] = 0.0;
    A2[155] = 0.0;
    A2[105] = 0.0;
    A2[98] = 0.0;
    A2[180] = -A2[183];
    A2[173] = 0.0;
    A2[118] = 0.0;
    A2[217] = 0.0;
    A2[200] = -A2[198];
    A2[6] = 0.0;
    A2[22] = 0.0;
    A2[9] = 0.0;
    A2[49] = 0.0;
    A2[34] = 0.0;
    A2[147] = 0.0;
    A2[124] = 0.0;
    A2[84] = 0.0;
    A2[67] = 0.0;
    A2[161] = 0.0;
    A2[136] = 0.0;
    A2[96] = 0.0;
    A2[81] = 0.0;
    A2[167] = 0.0;
    A2[156] = 0.0;
    A2[112] = 0.0;
    A2[223] = 0.0;
    A2[185] = -A2[184];
    A2[210] = 0.0;
    A2[203] = 0.0;
    A2[3] = 0.0;
    A2[59] = 0.0;
    A2[17] = 0.0;
    A2[134] = 0.0;
    A2[69] = 0.0;
    A2[48] = 0.0;
    A2[39] = 0.0;
    A2[121] = 0.0;
    A2[87] = 0.0;
    A2[64] = 0.0;
    A2[162] = 0.0;
    A2[93] = 0.0;
    A2[166] = 0.0;
    A2[115] = 0.0;
    A2[224] = 0.0;
    A2[190] = 0.0;
    A2[206] = 0.0;
    A2[0] = 0.0;
    A2[58] = 0.0;
    A2[28] = 0.0;
    A2[131] = 0.0;
    A2[74] = 0.0;
    A2[40] = 0.0;
    A2[145] = 0.0;
    A2[151] = 0.0;
    A2[102] = 0.0;
    A2[177] = 0.0;
    A2[114] = 0.0;
    A2[221] = 0.0;
    A2[196] = -A2[199];
    A2[209] = 0.0;
    A2[13] = 0.0;
    A2[53] = 0.0;
    A2[30] = 0.0;
    A2[23] = 0.0;
    A2[128] = 0.0;
    A2[63] = 0.0;
    A2[140] = 0.0;
    A2[77] = 0.0;
    A2[171] = 0.0;
    A2[152] = 0.0;
    
    double A3[225];
    A3[108] = 0.0;
    A3[99] = 0.0;
    A3[181] = 0.0;
    A3[176] = 0.0;
    A3[117] = 0.0;
    A3[214] = 0.0;
    A3[199] = 0.0;
    A3[192] = 0.0;
    A3[7] = 0.0;
    A3[21] = 0.0;
    A3[10] = 0.0;
    A3[52] = 0.0;
    A3[35] = 0.0;
    A3[26] = 0.0;
    A3[125] = 0.0;
    A3[83] = 0.0;
    A3[60] = 0.0;
    A3[158] = 0.0;
    A3[135] = 0.0;
    A3[97] = 0.0;
    A3[80] = 0.0;
    A3[170] = 0.0;
    A3[157] = 0.0;
    A3[111] = 0.0;
    A3[100] = 0.0;
    A3[211] = 0.0;
    A3[202] = 0.166666666666667*G3_0;
    A3[186] = -A3[202] - 0.166666666666667*G3_1;
    A3[4] = 0.0;
    A3[16] = 0.0;
    A3[70] = 0.0;
    A3[47] = 0.0;
    A3[36] = 0.0;
    A3[149] = 0.0;
    A3[122] = 0.0;
    A3[86] = 0.0;
    A3[65] = 0.0;
    A3[163] = 0.0;
    A3[138] = 0.0;
    A3[90] = 0.0;
    A3[165] = 0.0;
    A3[110] = 0.0;
    A3[191] = A3[202] - 0.166666666666667*G3_1;
    A3[212] = 0.0;
    A3[205] = -A3[202];
    A3[1] = 0.0;
    A3[57] = 0.0;
    A3[27] = 0.0;
    A3[132] = 0.0;
    A3[46] = 0.0;
    A3[41] = 0.0;
    A3[144] = 0.0;
    A3[89] = 0.0;
    A3[164] = 0.0;
    A3[103] = 0.0;
    A3[113] = 0.0;
    A3[218] = 0.166666666666667*G3_1;
    A3[195] = 0.0;
    A3[188] = 0.0;
    A3[208] = 0.0;
    A3[14] = 0.0;
    A3[56] = 0.0;
    A3[31] = 0.0;
    A3[129] = 0.0;
    A3[72] = 0.0;
    A3[42] = 0.0;
    A3[139] = 0.0;
    A3[76] = 0.0;
    A3[153] = 0.0;
    A3[107] = 0.0;
    A3[104] = 0.0;
    A3[182] = 0.0;
    A3[175] = 0.0;
    A3[215] = 0.0;
    A3[198] = 0.0;
    A3[193] = 0.0;
    A3[20] = 0.0;
    A3[11] = 0.0;
    A3[51] = 0.0;
    A3[32] = 0.0;
    A3[25] = 0.0;
    A3[126] = 0.0;
    A3[61] = 0.0;
    A3[159] = 0.0;
    A3[142] = 0.0;
    A3[94] = 0.0;
    A3[79] = 0.0;
    A3[169] = 0.0;
    A3[154] = 0.0;
    A3[106] = 0.0;
    A3[101] = 0.0;
    A3[187] = 0.0;
    A3[174] = 0.0;
    A3[216] = 0.0;
    A3[201] = 0.0;
    A3[5] = 0.0;
    A3[15] = 0.0;
    A3[8] = 0.0;
    A3[71] = 0.0;
    A3[50] = 0.0;
    A3[37] = 0.0;
    A3[148] = 0.0;
    A3[123] = 0.0;
    A3[85] = 0.0;
    A3[66] = 0.0;
    A3[160] = 0.0;
    A3[137] = 0.0;
    A3[91] = 0.0;
    A3[82] = 0.0;
    A3[168] = 0.0;
    A3[109] = 0.0;
    A3[222] = 0.0;
    A3[184] = 0.0;
    A3[213] = 0.0;
    A3[204] = A3[202] + 0.333333333333333*G3_1;
    A3[2] = 0.0;
    A3[18] = 0.0;
    A3[133] = 0.0;
    A3[68] = 0.0;
    A3[45] = 0.0;
    A3[38] = 0.0;
    A3[143] = 0.0;
    A3[120] = 0.0;
    A3[88] = 0.0;
    A3[92] = 0.0;
    A3[179] = 0.0;
    A3[116] = 0.0;
    A3[219] = -A3[186] + 0.166666666666666*G3_0;
    A3[189] = -A3[186];
    A3[207] = 0.0;
    A3[55] = 0.0;
    A3[29] = 0.0;
    A3[130] = 0.0;
    A3[73] = 0.0;
    A3[43] = 0.0;
    A3[146] = 0.0;
    A3[75] = 0.0;
    A3[150] = 0.0;
    A3[183] = 0.0;
    A3[178] = 0.0;
    A3[119] = 0.0;
    A3[220] = -A3[219];
    A3[197] = 0.0;
    A3[194] = 0.0;
    A3[19] = 0.0;
    A3[12] = 0.0;
    A3[54] = 0.0;
    A3[33] = 0.0;
    A3[24] = 0.0;
    A3[127] = 0.0;
    A3[62] = 0.0;
    A3[44] = 0.0;
    A3[141] = 0.0;
    A3[95] = 0.0;
    A3[78] = 0.0;
    A3[172] = 0.0;
    A3[155] = 0.0;
    A3[105] = 0.0;
    A3[98] = 0.0;
    A3[180] = 0.0;
    A3[173] = 0.0;
    A3[118] = 0.0;
    A3[217] = 0.0;
    A3[200] = 0.0;
    A3[6] = 0.0;
    A3[22] = 0.0;
    A3[9] = 0.0;
    A3[49] = 0.0;
    A3[34] = 0.0;
    A3[147] = 0.0;
    A3[124] = 0.0;
    A3[84] = 0.0;
    A3[67] = 0.0;
    A3[161] = 0.0;
    A3[136] = 0.0;
    A3[96] = 0.0;
    A3[81] = 0.0;
    A3[167] = 0.0;
    A3[156] = 0.0;
    A3[112] = 0.0;
    A3[223] = 0.0;
    A3[185] = 0.0;
    A3[210] = 0.0;
    A3[203] = 0.0;
    A3[3] = 0.0;
    A3[59] = 0.0;
    A3[17] = 0.0;
    A3[134] = 0.0;
    A3[69] = 0.0;
    A3[48] = 0.0;
    A3[39] = 0.0;
    A3[121] = 0.0;
    A3[87] = 0.0;
    A3[64] = 0.0;
    A3[162] = 0.0;
    A3[93] = 0.0;
    A3[166] = 0.0;
    A3[115] = 0.0;
    A3[224] = 0.0;
    A3[190] = -A3[191];
    A3[206] = -A3[204];
    A3[0] = 0.0;
    A3[58] = 0.0;
    A3[28] = 0.0;
    A3[131] = 0.0;
    A3[74] = 0.0;
    A3[40] = 0.0;
    A3[145] = 0.0;
    A3[151] = 0.0;
    A3[102] = 0.0;
    A3[177] = 0.0;
    A3[114] = 0.0;
    A3[221] = -A3[218];
    A3[196] = 0.0;
    A3[209] = 0.0;
    A3[13] = 0.0;
    A3[53] = 0.0;
    A3[30] = 0.0;
    A3[23] = 0.0;
    A3[128] = 0.0;
    A3[63] = 0.0;
    A3[140] = 0.0;
    A3[77] = 0.0;
    A3[171] = 0.0;
    A3[152] = 0.0;
    
    double A4[225];
    A4[108] = 0.0;
    A4[99] = 0.0;
    A4[181] = 0.0;
    A4[176] = 0.0;
    A4[117] = 0.0;
    A4[214] = 0.0;
    A4[199] = 0.0;
    A4[192] = 0.0;
    A4[7] = 0.0;
    A4[21] = 0.0;
    A4[10] = 0.0;
    A4[52] = 0.0;
    A4[35] = 0.0;
    A4[26] = 0.0;
    A4[125] = 0.0;
    A4[83] = 0.0;
    A4[158] = 0.0;
    A4[135] = 0.0;
    A4[97] = 0.0;
    A4[170] = 0.0;
    A4[157] = 0.0;
    A4[111] = 0.0;
    A4[100] = 0.0;
    A4[186] = 0.0;
    A4[211] = 0.0;
    A4[202] = 0.0;
    A4[16] = 0.5*G4_0_0_0;
    A4[70] = 0.0;
    A4[47] = 0.666666666666666*G4_0_0_1;
    A4[4] = -A4[47] - 0.666666666666667*G4_0_1_1;
    A4[36] = 0.0;
    A4[149] = 0.0;
    A4[122] = 0.0;
    A4[86] = 0.0;
    A4[65] = A4[47] + 0.666666666666667*G4_0_1_0;
    A4[163] = 0.0;
    A4[138] = 0.0;
    A4[90] = 0.0;
    A4[165] = 0.0;
    A4[110] = 0.0;
    A4[191] = 0.0;
    A4[212] = 0.0;
    A4[205] = 0.0;
    A4[57] = 0.0;
    A4[27] = 0.0;
    A4[132] = 0.0;
    A4[46] = 0.666666666666666*G4_0_1_0;
    A4[60] = -A4[46] - 0.666666666666666*G4_0_1_1;
    A4[41] = 0.0;
    A4[144] = 0.0;
    A4[89] = 0.0;
    A4[164] = 0.0;
    A4[103] = 0.0;
    A4[113] = 0.0;
    A4[218] = 0.0;
    A4[195] = 0.0;
    A4[188] = 0.0;
    A4[208] = 0.0;
    A4[14] = 0.0;
    A4[56] = 0.0;
    A4[31] = -0.166666666666667*G4_0_1_0;
    A4[1] = -A4[31] + 0.166666666666667*G4_0_0_0;
    A4[129] = 0.0;
    A4[72] = 0.0;
    A4[42] = 0.0;
    A4[139] = 0.0;
    A4[76] = -A4[46] - 0.666666666666667*G4_0_0_0;
    A4[153] = 0.0;
    A4[107] = 0.0;
    A4[104] = 0.0;
    A4[182] = 0.0;
    A4[175] = 0.0;
    A4[215] = 0.0;
    A4[198] = 0.0;
    A4[193] = 0.0;
    A4[20] = -A4[47] - 0.666666666666667*G4_0_0_0;
    A4[11] = 0.0;
    A4[51] = 0.0;
    A4[32] = 0.5*G4_0_1_1;
    A4[25] = 0.0;
    A4[126] = 0.0;
    A4[61] = 0.0;
    A4[159] = 0.0;
    A4[142] = 0.0;
    A4[94] = 0.0;
    A4[79] = A4[65];
    A4[169] = 0.0;
    A4[154] = 0.0;
    A4[106] = 0.0;
    A4[101] = 0.0;
    A4[187] = 0.0;
    A4[174] = 0.0;
    A4[216] = 0.0;
    A4[201] = 0.0;
    A4[5] = A4[76];
    A4[15] = -0.25*A4[20];
    A4[8] = 0.0;
    A4[71] = 0.0;
    A4[50] = -A4[65] - 1.33333333333333*G4_0_1_1;
    A4[80] = -A4[50] + 1.33333333333333*G4_0_0_0;
    A4[37] = 0.0;
    A4[148] = 0.0;
    A4[123] = 0.0;
    A4[85] = 0.0;
    A4[66] = 0.0;
    A4[160] = 0.0;
    A4[137] = 0.0;
    A4[91] = 0.0;
    A4[82] = 0.0;
    A4[168] = 0.0;
    A4[109] = 0.0;
    A4[222] = 0.0;
    A4[184] = 0.0;
    A4[213] = 0.0;
    A4[204] = 0.0;
    A4[2] = -0.25*A4[4];
    A4[18] = A4[47];
    A4[133] = 0.0;
    A4[68] = 0.0;
    A4[45] = 0.0;
    A4[38] = 0.0;
    A4[143] = 0.0;
    A4[120] = 0.0;
    A4[88] = 0.0;
    A4[92] = 0.0;
    A4[179] = 0.0;
    A4[116] = 0.0;
    A4[219] = 0.0;
    A4[189] = 0.0;
    A4[207] = 0.0;
    A4[55] = 0.0;
    A4[29] = 0.0;
    A4[130] = 0.0;
    A4[73] = 0.0;
    A4[43] = 0.0;
    A4[146] = 0.0;
    A4[75] = A4[20];
    A4[150] = 0.0;
    A4[183] = 0.0;
    A4[178] = 0.0;
    A4[119] = 0.0;
    A4[220] = 0.0;
    A4[197] = 0.0;
    A4[194] = 0.0;
    A4[19] = 0.0;
    A4[12] = 0.0;
    A4[54] = 0.0;
    A4[33] = A4[46];
    A4[24] = 0.0;
    A4[127] = 0.0;
    A4[62] = A4[4];
    A4[44] = 0.0;
    A4[141] = 0.0;
    A4[95] = 0.0;
    A4[78] = A4[50];
    A4[172] = 0.0;
    A4[155] = 0.0;
    A4[105] = 0.0;
    A4[98] = 0.0;
    A4[180] = 0.0;
    A4[173] = 0.0;
    A4[118] = 0.0;
    A4[217] = 0.0;
    A4[200] = 0.0;
    A4[6] = 0.0;
    A4[22] = 0.0;
    A4[9] = 0.0;
    A4[49] = -A4[65] - 1.33333333333333*G4_0_0_0;
    A4[34] = A4[60];
    A4[147] = 0.0;
    A4[124] = 0.0;
    A4[84] = 0.0;
    A4[67] = 0.0;
    A4[161] = 0.0;
    A4[136] = 0.0;
    A4[96] = 0.0;
    A4[81] = 0.0;
    A4[167] = 0.0;
    A4[156] = 0.0;
    A4[112] = 0.0;
    A4[223] = 0.0;
    A4[185] = 0.0;
    A4[210] = 0.0;
    A4[203] = 0.0;
    A4[3] = 0.0;
    A4[59] = 0.0;
    A4[17] = -0.166666666666667*G4_0_0_1;
    A4[134] = 0.0;
    A4[69] = 0.0;
    A4[48] = A4[80];
    A4[39] = 0.0;
    A4[121] = 0.0;
    A4[87] = 0.0;
    A4[64] = A4[80];
    A4[162] = 0.0;
    A4[93] = 0.0;
    A4[166] = 0.0;
    A4[115] = 0.0;
    A4[224] = 0.0;
    A4[190] = 0.0;
    A4[206] = 0.0;
    A4[0] = A4[16] + 0.5*G4_0_0_1 + 0.5*G4_0_1_0 + 0.5*G4_0_1_1;
    A4[58] = 0.0;
    A4[28] = 0.0;
    A4[131] = 0.0;
    A4[74] = 0.0;
    A4[40] = 0.0;
    A4[145] = 0.0;
    A4[151] = 0.0;
    A4[102] = 0.0;
    A4[177] = 0.0;
    A4[114] = 0.0;
    A4[221] = 0.0;
    A4[196] = 0.0;
    A4[209] = 0.0;
    A4[13] = 0.0;
    A4[53] = 0.0;
    A4[30] = -0.25*A4[60];
    A4[23] = 0.0;
    A4[128] = 0.0;
    A4[63] = A4[49];
    A4[140] = 0.0;
    A4[77] = 0.0;
    A4[171] = 0.0;
    A4[152] = 0.0;
    
    double A5[225];
    A5[108] = 0.0;
    A5[99] = 0.0;
    A5[181] = 0.0;
    A5[117] = 0.0;
    A5[214] = 0.0;
    A5[199] = 0.0;
    A5[192] = 0.0;
    A5[7] = 0.0;
    A5[21] = 0.0;
    A5[10] = 0.0;
    A5[52] = 0.0;
    A5[35] = 0.0;
    A5[26] = 0.0;
    A5[125] = 0.0;
    A5[83] = 0.0;
    A5[60] = 0.0;
    A5[135] = 0.0;
    A5[80] = 0.0;
    A5[170] = 0.0;
    A5[157] = 0.0;
    A5[186] = 0.0;
    A5[211] = 0.0;
    A5[202] = 0.0;
    A5[4] = 0.0;
    A5[16] = 0.0;
    A5[70] = 0.0;
    A5[47] = 0.0;
    A5[36] = 0.0;
    A5[149] = 0.0;
    A5[122] = 0.0;
    A5[86] = 0.0;
    A5[65] = 0.0;
    A5[163] = 0.0;
    A5[138] = 0.0;
    A5[90] = 0.0;
    A5[165] = 0.0;
    A5[110] = 0.0;
    A5[191] = 0.0;
    A5[212] = 0.0;
    A5[205] = 0.0;
    A5[1] = 0.0;
    A5[57] = 0.0;
    A5[27] = 0.0;
    A5[132] = 0.0;
    A5[46] = 0.0;
    A5[41] = 0.0;
    A5[89] = 0.0;
    A5[164] = 0.0;
    A5[103] = 0.0;
    A5[113] = -0.166666666666667*G5_0_0_1;
    A5[111] = -A5[113] + 0.166666666666667*G5_0_0_0;
    A5[218] = 0.0;
    A5[195] = 0.0;
    A5[188] = 0.0;
    A5[208] = 0.0;
    A5[14] = 0.0;
    A5[56] = 0.0;
    A5[31] = 0.0;
    A5[129] = 0.666666666666666*G5_0_1_0;
    A5[72] = 0.0;
    A5[42] = 0.0;
    A5[139] = 0.0;
    A5[76] = 0.0;
    A5[153] = 0.0;
    A5[107] = 0.0;
    A5[104] = 0.0;
    A5[182] = 0.0;
    A5[175] = A5[129] + 0.666666666666667*G5_0_0_1;
    A5[215] = 0.0;
    A5[198] = 0.0;
    A5[193] = 0.0;
    A5[20] = 0.0;
    A5[11] = 0.0;
    A5[51] = 0.0;
    A5[32] = 0.0;
    A5[25] = 0.0;
    A5[61] = 0.0;
    A5[159] = -A5[175] - 1.33333333333333*G5_0_0_0;
    A5[176] = -A5[159] + 1.33333333333333*G5_0_1_1;
    A5[144] = A5[176];
    A5[142] = A5[129];
    A5[94] = 0.0;
    A5[79] = 0.0;
    A5[169] = 0.0;
    A5[154] = 0.0;
    A5[106] = 0.0;
    A5[101] = -A5[129] - 0.666666666666667*G5_0_0_0;
    A5[97] = -0.25*A5[101];
    A5[187] = 0.0;
    A5[174] = -A5[175] - 1.33333333333333*G5_0_1_1;
    A5[216] = 0.0;
    A5[201] = 0.0;
    A5[5] = 0.0;
    A5[15] = 0.0;
    A5[8] = 0.0;
    A5[71] = 0.0;
    A5[50] = 0.0;
    A5[37] = 0.0;
    A5[148] = 0.0;
    A5[123] = 0.0;
    A5[85] = 0.0;
    A5[66] = 0.0;
    A5[160] = A5[176];
    A5[137] = 0.0;
    A5[91] = 0.0;
    A5[82] = 0.0;
    A5[168] = 0.0;
    A5[109] = 0.0;
    A5[222] = 0.0;
    A5[184] = 0.0;
    A5[213] = 0.0;
    A5[204] = 0.0;
    A5[2] = 0.0;
    A5[18] = 0.0;
    A5[133] = 0.0;
    A5[68] = 0.0;
    A5[45] = 0.0;
    A5[38] = 0.0;
    A5[143] = 0.666666666666666*G5_0_0_1;
    A5[158] = -A5[143] - 0.666666666666666*G5_0_1_1;
    A5[100] = A5[158];
    A5[120] = 0.0;
    A5[88] = 0.0;
    A5[92] = 0.0;
    A5[179] = 0.0;
    A5[116] = -4*A5[111];
    A5[219] = 0.0;
    A5[189] = 0.0;
    A5[207] = 0.0;
    A5[55] = 0.0;
    A5[29] = 0.0;
    A5[130] = -A5[129] - 0.666666666666666*G5_0_1_1;
    A5[126] = -0.25*A5[130];
    A5[73] = 0.0;
    A5[43] = 0.0;
    A5[146] = A5[174];
    A5[75] = 0.0;
    A5[150] = 0.0;
    A5[183] = 0.0;
    A5[178] = 0.0;
    A5[119] = 0.0;
    A5[220] = 0.0;
    A5[197] = 0.0;
    A5[194] = 0.0;
    A5[19] = 0.0;
    A5[12] = 0.0;
    A5[54] = 0.0;
    A5[33] = 0.0;
    A5[24] = 0.0;
    A5[127] = -0.166666666666667*G5_0_1_0;
    A5[62] = 0.0;
    A5[44] = 0.0;
    A5[141] = 0.0;
    A5[95] = 0.0;
    A5[78] = 0.0;
    A5[172] = A5[101];
    A5[155] = 0.0;
    A5[105] = 0.0;
    A5[98] = -A5[113] + 0.166666666666667*G5_0_1_1;
    A5[180] = 0.0;
    A5[173] = 0.0;
    A5[118] = 0.0;
    A5[217] = 0.0;
    A5[200] = 0.0;
    A5[6] = 0.0;
    A5[22] = 0.0;
    A5[9] = 0.0;
    A5[49] = 0.0;
    A5[34] = 0.0;
    A5[147] = 0.0;
    A5[124] = 0.0;
    A5[84] = 0.0;
    A5[67] = 0.0;
    A5[161] = A5[175];
    A5[136] = 0.0;
    A5[81] = 0.0;
    A5[167] = 0.0;
    A5[156] = A5[130];
    A5[112] = 0.5*G5_0_0_0;
    A5[96] = A5[112] + 0.5*G5_0_0_1 + 0.5*G5_0_1_0 + 0.5*G5_0_1_1;
    A5[223] = 0.0;
    A5[185] = 0.0;
    A5[210] = 0.0;
    A5[203] = 0.0;
    A5[3] = 0.0;
    A5[59] = 0.0;
    A5[17] = 0.0;
    A5[134] = 0.0;
    A5[69] = 0.0;
    A5[48] = 0.0;
    A5[39] = 0.0;
    A5[121] = 0.0;
    A5[87] = 0.0;
    A5[64] = 0.0;
    A5[162] = 0.0;
    A5[93] = 0.0;
    A5[166] = 0.0;
    A5[115] = 0.0;
    A5[224] = 0.0;
    A5[190] = 0.0;
    A5[206] = 0.0;
    A5[0] = 0.0;
    A5[58] = 0.0;
    A5[28] = 0.0;
    A5[131] = 0.0;
    A5[74] = 0.0;
    A5[40] = 0.0;
    A5[145] = A5[159];
    A5[151] = 0.0;
    A5[102] = 0.0;
    A5[177] = 0.0;
    A5[114] = A5[143];
    A5[221] = 0.0;
    A5[196] = 0.0;
    A5[209] = 0.0;
    A5[13] = 0.0;
    A5[53] = 0.0;
    A5[30] = 0.0;
    A5[23] = 0.0;
    A5[128] = 0.5*G5_0_1_1;
    A5[63] = 0.0;
    A5[140] = 0.0;
    A5[77] = 0.0;
    A5[171] = A5[116];
    A5[152] = 0.0;
    
    double A6[225];
    A6[108] = 0.0;
    A6[99] = 0.0;
    A6[181] = 0.0;
    A6[176] = 0.0;
    A6[117] = 0.0;
    A6[214] = 0.0;
    A6[199] = 0.0;
    A6[192] = 0.0;
    A6[7] = 0.0;
    A6[21] = 0.0;
    A6[10] = 0.0;
    A6[52] = 0.0;
    A6[35] = 0.0;
    A6[26] = 0.0;
    A6[125] = 0.0;
    A6[83] = 0.0;
    A6[158] = 0.0;
    A6[135] = 0.0;
    A6[97] = 0.0;
    A6[170] = 0.0;
    A6[157] = 0.0;
    A6[111] = 0.0;
    A6[100] = 0.0;
    A6[186] = 0.0;
    A6[211] = 0.0;
    A6[202] = 0.0;
    A6[16] = 0.5*G6_0_0_0;
    A6[70] = 0.0;
    A6[47] = 0.666666666666666*G6_0_0_1;
    A6[4] = -A6[47] - 0.666666666666667*G6_0_1_1;
    A6[36] = 0.0;
    A6[149] = 0.0;
    A6[122] = 0.0;
    A6[86] = 0.0;
    A6[65] = A6[47] + 0.666666666666667*G6_0_1_0;
    A6[163] = 0.0;
    A6[138] = 0.0;
    A6[90] = 0.0;
    A6[165] = 0.0;
    A6[110] = 0.0;
    A6[191] = 0.0;
    A6[212] = 0.0;
    A6[205] = 0.0;
    A6[57] = 0.0;
    A6[27] = 0.0;
    A6[132] = 0.0;
    A6[46] = 0.666666666666666*G6_0_1_0;
    A6[60] = -A6[46] - 0.666666666666666*G6_0_1_1;
    A6[41] = 0.0;
    A6[144] = 0.0;
    A6[89] = 0.0;
    A6[164] = 0.0;
    A6[103] = 0.0;
    A6[113] = 0.0;
    A6[218] = 0.0;
    A6[195] = 0.0;
    A6[188] = 0.0;
    A6[208] = 0.0;
    A6[14] = 0.0;
    A6[56] = 0.0;
    A6[31] = -0.166666666666667*G6_0_1_0;
    A6[1] = -A6[31] + 0.166666666666667*G6_0_0_0;
    A6[129] = 0.0;
    A6[72] = 0.0;
    A6[42] = 0.0;
    A6[139] = 0.0;
    A6[76] = -A6[46] - 0.666666666666667*G6_0_0_0;
    A6[153] = 0.0;
    A6[107] = 0.0;
    A6[104] = 0.0;
    A6[182] = 0.0;
    A6[175] = 0.0;
    A6[215] = 0.0;
    A6[198] = 0.0;
    A6[193] = 0.0;
    A6[20] = -A6[47] - 0.666666666666667*G6_0_0_0;
    A6[11] = 0.0;
    A6[51] = 0.0;
    A6[32] = 0.5*G6_0_1_1;
    A6[25] = 0.0;
    A6[126] = 0.0;
    A6[61] = 0.0;
    A6[159] = 0.0;
    A6[142] = 0.0;
    A6[94] = 0.0;
    A6[79] = A6[65];
    A6[169] = 0.0;
    A6[154] = 0.0;
    A6[106] = 0.0;
    A6[101] = 0.0;
    A6[187] = 0.0;
    A6[174] = 0.0;
    A6[216] = 0.0;
    A6[201] = 0.0;
    A6[5] = A6[76];
    A6[15] = -0.25*A6[20];
    A6[8] = 0.0;
    A6[71] = 0.0;
    A6[50] = -A6[65] - 1.33333333333333*G6_0_1_1;
    A6[80] = -A6[50] + 1.33333333333333*G6_0_0_0;
    A6[37] = 0.0;
    A6[148] = 0.0;
    A6[123] = 0.0;
    A6[85] = 0.0;
    A6[66] = 0.0;
    A6[160] = 0.0;
    A6[137] = 0.0;
    A6[91] = 0.0;
    A6[82] = 0.0;
    A6[168] = 0.0;
    A6[109] = 0.0;
    A6[222] = 0.0;
    A6[184] = 0.0;
    A6[213] = 0.0;
    A6[204] = 0.0;
    A6[2] = -0.25*A6[4];
    A6[18] = A6[47];
    A6[133] = 0.0;
    A6[68] = 0.0;
    A6[45] = 0.0;
    A6[38] = 0.0;
    A6[143] = 0.0;
    A6[120] = 0.0;
    A6[88] = 0.0;
    A6[92] = 0.0;
    A6[179] = 0.0;
    A6[116] = 0.0;
    A6[219] = 0.0;
    A6[189] = 0.0;
    A6[207] = 0.0;
    A6[55] = 0.0;
    A6[29] = 0.0;
    A6[130] = 0.0;
    A6[73] = 0.0;
    A6[43] = 0.0;
    A6[146] = 0.0;
    A6[75] = A6[20];
    A6[150] = 0.0;
    A6[183] = 0.0;
    A6[178] = 0.0;
    A6[119] = 0.0;
    A6[220] = 0.0;
    A6[197] = 0.0;
    A6[194] = 0.0;
    A6[19] = 0.0;
    A6[12] = 0.0;
    A6[54] = 0.0;
    A6[33] = A6[46];
    A6[24] = 0.0;
    A6[127] = 0.0;
    A6[62] = A6[4];
    A6[44] = 0.0;
    A6[141] = 0.0;
    A6[95] = 0.0;
    A6[78] = A6[50];
    A6[172] = 0.0;
    A6[155] = 0.0;
    A6[105] = 0.0;
    A6[98] = 0.0;
    A6[180] = 0.0;
    A6[173] = 0.0;
    A6[118] = 0.0;
    A6[217] = 0.0;
    A6[200] = 0.0;
    A6[6] = 0.0;
    A6[22] = 0.0;
    A6[9] = 0.0;
    A6[49] = -A6[65] - 1.33333333333333*G6_0_0_0;
    A6[34] = A6[60];
    A6[147] = 0.0;
    A6[124] = 0.0;
    A6[84] = 0.0;
    A6[67] = 0.0;
    A6[161] = 0.0;
    A6[136] = 0.0;
    A6[96] = 0.0;
    A6[81] = 0.0;
    A6[167] = 0.0;
    A6[156] = 0.0;
    A6[112] = 0.0;
    A6[223] = 0.0;
    A6[185] = 0.0;
    A6[210] = 0.0;
    A6[203] = 0.0;
    A6[3] = 0.0;
    A6[59] = 0.0;
    A6[17] = -0.166666666666667*G6_0_0_1;
    A6[134] = 0.0;
    A6[69] = 0.0;
    A6[48] = A6[80];
    A6[39] = 0.0;
    A6[121] = 0.0;
    A6[87] = 0.0;
    A6[64] = A6[80];
    A6[162] = 0.0;
    A6[93] = 0.0;
    A6[166] = 0.0;
    A6[115] = 0.0;
    A6[224] = 0.0;
    A6[190] = 0.0;
    A6[206] = 0.0;
    A6[0] = A6[16] + 0.5*G6_0_0_1 + 0.5*G6_0_1_0 + 0.5*G6_0_1_1;
    A6[58] = 0.0;
    A6[28] = 0.0;
    A6[131] = 0.0;
    A6[74] = 0.0;
    A6[40] = 0.0;
    A6[145] = 0.0;
    A6[151] = 0.0;
    A6[102] = 0.0;
    A6[177] = 0.0;
    A6[114] = 0.0;
    A6[221] = 0.0;
    A6[196] = 0.0;
    A6[209] = 0.0;
    A6[13] = 0.0;
    A6[53] = 0.0;
    A6[30] = -0.25*A6[60];
    A6[23] = 0.0;
    A6[128] = 0.0;
    A6[63] = A6[49];
    A6[140] = 0.0;
    A6[77] = 0.0;
    A6[171] = 0.0;
    A6[152] = 0.0;
    
    double A7[225];
    A7[108] = 0.0;
    A7[99] = 0.0;
    A7[181] = 0.0;
    A7[117] = 0.0;
    A7[214] = 0.0;
    A7[199] = 0.0;
    A7[192] = 0.0;
    A7[7] = 0.0;
    A7[21] = 0.0;
    A7[10] = 0.0;
    A7[52] = 0.0;
    A7[35] = 0.0;
    A7[26] = 0.0;
    A7[125] = 0.0;
    A7[83] = 0.0;
    A7[60] = 0.0;
    A7[135] = 0.0;
    A7[80] = 0.0;
    A7[170] = 0.0;
    A7[157] = 0.0;
    A7[186] = 0.0;
    A7[211] = 0.0;
    A7[202] = 0.0;
    A7[4] = 0.0;
    A7[16] = 0.0;
    A7[70] = 0.0;
    A7[47] = 0.0;
    A7[36] = 0.0;
    A7[149] = 0.0;
    A7[122] = 0.0;
    A7[86] = 0.0;
    A7[65] = 0.0;
    A7[163] = 0.0;
    A7[138] = 0.0;
    A7[90] = 0.0;
    A7[165] = 0.0;
    A7[110] = 0.0;
    A7[191] = 0.0;
    A7[212] = 0.0;
    A7[205] = 0.0;
    A7[1] = 0.0;
    A7[57] = 0.0;
    A7[27] = 0.0;
    A7[132] = 0.0;
    A7[46] = 0.0;
    A7[41] = 0.0;
    A7[89] = 0.0;
    A7[164] = 0.0;
    A7[103] = 0.0;
    A7[113] = -0.166666666666667*G7_0_0_1;
    A7[111] = -A7[113] + 0.166666666666667*G7_0_0_0;
    A7[218] = 0.0;
    A7[195] = 0.0;
    A7[188] = 0.0;
    A7[208] = 0.0;
    A7[14] = 0.0;
    A7[56] = 0.0;
    A7[31] = 0.0;
    A7[129] = 0.666666666666666*G7_0_1_0;
    A7[72] = 0.0;
    A7[42] = 0.0;
    A7[139] = 0.0;
    A7[76] = 0.0;
    A7[153] = 0.0;
    A7[107] = 0.0;
    A7[104] = 0.0;
    A7[182] = 0.0;
    A7[175] = A7[129] + 0.666666666666667*G7_0_0_1;
    A7[215] = 0.0;
    A7[198] = 0.0;
    A7[193] = 0.0;
    A7[20] = 0.0;
    A7[11] = 0.0;
    A7[51] = 0.0;
    A7[32] = 0.0;
    A7[25] = 0.0;
    A7[61] = 0.0;
    A7[159] = -A7[175] - 1.33333333333333*G7_0_0_0;
    A7[176] = -A7[159] + 1.33333333333333*G7_0_1_1;
    A7[144] = A7[176];
    A7[142] = A7[129];
    A7[94] = 0.0;
    A7[79] = 0.0;
    A7[169] = 0.0;
    A7[154] = 0.0;
    A7[106] = 0.0;
    A7[101] = -A7[129] - 0.666666666666667*G7_0_0_0;
    A7[97] = -0.25*A7[101];
    A7[187] = 0.0;
    A7[174] = -A7[175] - 1.33333333333333*G7_0_1_1;
    A7[216] = 0.0;
    A7[201] = 0.0;
    A7[5] = 0.0;
    A7[15] = 0.0;
    A7[8] = 0.0;
    A7[71] = 0.0;
    A7[50] = 0.0;
    A7[37] = 0.0;
    A7[148] = 0.0;
    A7[123] = 0.0;
    A7[85] = 0.0;
    A7[66] = 0.0;
    A7[160] = A7[176];
    A7[137] = 0.0;
    A7[91] = 0.0;
    A7[82] = 0.0;
    A7[168] = 0.0;
    A7[109] = 0.0;
    A7[222] = 0.0;
    A7[184] = 0.0;
    A7[213] = 0.0;
    A7[204] = 0.0;
    A7[2] = 0.0;
    A7[18] = 0.0;
    A7[133] = 0.0;
    A7[68] = 0.0;
    A7[45] = 0.0;
    A7[38] = 0.0;
    A7[143] = 0.666666666666666*G7_0_0_1;
    A7[158] = -A7[143] - 0.666666666666666*G7_0_1_1;
    A7[100] = A7[158];
    A7[120] = 0.0;
    A7[88] = 0.0;
    A7[92] = 0.0;
    A7[179] = 0.0;
    A7[116] = -4*A7[111];
    A7[219] = 0.0;
    A7[189] = 0.0;
    A7[207] = 0.0;
    A7[55] = 0.0;
    A7[29] = 0.0;
    A7[130] = -A7[129] - 0.666666666666666*G7_0_1_1;
    A7[126] = -0.25*A7[130];
    A7[73] = 0.0;
    A7[43] = 0.0;
    A7[146] = A7[174];
    A7[75] = 0.0;
    A7[150] = 0.0;
    A7[183] = 0.0;
    A7[178] = 0.0;
    A7[119] = 0.0;
    A7[220] = 0.0;
    A7[197] = 0.0;
    A7[194] = 0.0;
    A7[19] = 0.0;
    A7[12] = 0.0;
    A7[54] = 0.0;
    A7[33] = 0.0;
    A7[24] = 0.0;
    A7[127] = -0.166666666666667*G7_0_1_0;
    A7[62] = 0.0;
    A7[44] = 0.0;
    A7[141] = 0.0;
    A7[95] = 0.0;
    A7[78] = 0.0;
    A7[172] = A7[101];
    A7[155] = 0.0;
    A7[105] = 0.0;
    A7[98] = -A7[113] + 0.166666666666667*G7_0_1_1;
    A7[180] = 0.0;
    A7[173] = 0.0;
    A7[118] = 0.0;
    A7[217] = 0.0;
    A7[200] = 0.0;
    A7[6] = 0.0;
    A7[22] = 0.0;
    A7[9] = 0.0;
    A7[49] = 0.0;
    A7[34] = 0.0;
    A7[147] = 0.0;
    A7[124] = 0.0;
    A7[84] = 0.0;
    A7[67] = 0.0;
    A7[161] = A7[175];
    A7[136] = 0.0;
    A7[81] = 0.0;
    A7[167] = 0.0;
    A7[156] = A7[130];
    A7[112] = 0.5*G7_0_0_0;
    A7[96] = A7[112] + 0.5*G7_0_0_1 + 0.5*G7_0_1_0 + 0.5*G7_0_1_1;
    A7[223] = 0.0;
    A7[185] = 0.0;
    A7[210] = 0.0;
    A7[203] = 0.0;
    A7[3] = 0.0;
    A7[59] = 0.0;
    A7[17] = 0.0;
    A7[134] = 0.0;
    A7[69] = 0.0;
    A7[48] = 0.0;
    A7[39] = 0.0;
    A7[121] = 0.0;
    A7[87] = 0.0;
    A7[64] = 0.0;
    A7[162] = 0.0;
    A7[93] = 0.0;
    A7[166] = 0.0;
    A7[115] = 0.0;
    A7[224] = 0.0;
    A7[190] = 0.0;
    A7[206] = 0.0;
    A7[0] = 0.0;
    A7[58] = 0.0;
    A7[28] = 0.0;
    A7[131] = 0.0;
    A7[74] = 0.0;
    A7[40] = 0.0;
    A7[145] = A7[159];
    A7[151] = 0.0;
    A7[102] = 0.0;
    A7[177] = 0.0;
    A7[114] = A7[143];
    A7[221] = 0.0;
    A7[196] = 0.0;
    A7[209] = 0.0;
    A7[13] = 0.0;
    A7[53] = 0.0;
    A7[30] = 0.0;
    A7[23] = 0.0;
    A7[128] = 0.5*G7_0_1_1;
    A7[63] = 0.0;
    A7[140] = 0.0;
    A7[77] = 0.0;
    A7[171] = A7[116];
    A7[152] = 0.0;
    
    double A8[225];
    A8[108] = 0.0;
    A8[99] = 0.0;
    A8[181] = 0.0;
    A8[176] = 0.0;
    A8[117] = 0.0;
    A8[214] = 0.0;
    A8[199] = 0.0;
    A8[192] = 0.0;
    A8[7] = 0.0;
    A8[21] = 0.0;
    A8[10] = 0.0;
    A8[52] = 0.0;
    A8[35] = 0.00793650793650793*G8_0_0 + 0.00793650793650793*G8_0_1 - 0.00793650793650793*G8_1_0 + 0.00476190476190476*G8_2_1 - 0.00634920634920633*G8_3_0 - 0.019047619047619*G8_3_1 + 0.00634920634920633*G8_4_0 - 0.0126984126984127*G8_4_1 + 0.019047619047619*G8_5_1;
    A8[26] = 0.0;
    A8[125] = 0.0;
    A8[83] = 0.0;
    A8[158] = 0.0;
    A8[135] = 0.0;
    A8[97] = 0.0;
    A8[80] = -8.00000000000001*A8[35];
    A8[170] = 0.0;
    A8[157] = 0.0;
    A8[111] = 0.0;
    A8[100] = 0.0;
    A8[186] = 0.0;
    A8[211] = 0.0;
    A8[202] = 0.0;
    A8[16] = 0.00714285714285713*G8_0_0 + 0.00714285714285714*G8_0_1 + 0.0309523809523809*G8_1_0 - 0.00714285714285713*G8_2_1 + 0.0095238095238095*G8_3_0 + 0.0476190476190476*G8_3_1 - 0.0095238095238095*G8_4_0 - 0.0380952380952381*G8_5_0 - 0.0476190476190476*G8_5_1;
    A8[70] = 0.0;
    A8[36] = 0.0;
    A8[149] = 0.0;
    A8[122] = 0.0;
    A8[86] = 0.0;
    A8[65] = A8[80] + 0.0317460317460317*G8_0_0 + 0.0317460317460317*G8_0_1 - 0.0571428571428572*G8_1_0 + 0.0444444444444444*G8_2_1 - 0.101587301587302*G8_3_1 - 0.0761904761904762*G8_4_1 + 0.0253968253968254*G8_5_0 + 0.101587301587302*G8_5_1;
    A8[163] = 0.0;
    A8[138] = 0.0;
    A8[90] = 0.0;
    A8[165] = 0.0;
    A8[110] = 0.0;
    A8[191] = 0.0;
    A8[212] = 0.0;
    A8[205] = 0.0;
    A8[57] = 0.0;
    A8[27] = 0.0;
    A8[132] = 0.0;
    A8[41] = 0.0;
    A8[144] = 0.0;
    A8[89] = 0.0;
    A8[164] = 0.0;
    A8[103] = 0.0;
    A8[113] = 0.0;
    A8[218] = 0.0;
    A8[195] = 0.0;
    A8[188] = 0.0;
    A8[208] = 0.0;
    A8[14] = 0.0;
    A8[56] = 0.0;
    A8[129] = 0.0;
    A8[72] = 0.0;
    A8[42] = 0.0;
    A8[139] = 0.0;
    A8[153] = 0.0;
    A8[107] = 0.0;
    A8[104] = 0.0;
    A8[182] = 0.0;
    A8[175] = 0.0;
    A8[215] = 0.0;
    A8[198] = 0.0;
    A8[193] = 0.0;
    A8[11] = 0.0;
    A8[51] = 0.0;
    A8[25] = 0.0;
    A8[126] = 0.0;
    A8[159] = 0.0;
    A8[142] = 0.0;
    A8[94] = 0.0;
    A8[79] = A8[65];
    A8[169] = 0.0;
    A8[154] = 0.0;
    A8[106] = 0.0;
    A8[101] = 0.0;
    A8[187] = 0.0;
    A8[174] = 0.0;
    A8[216] = 0.0;
    A8[201] = 0.0;
    A8[8] = 0.0;
    A8[71] = 0.0;
    A8[50] = A8[65] + 0.0253968253968254*G8_0_0 + 0.0253968253968254*G8_0_1 + 0.0253968253968254*G8_1_0 + 0.0253968253968254*G8_3_1 - 0.0253968253968254*G8_4_1 - 0.0507936507936508*G8_5_0 - 0.0253968253968254*G8_5_1;
    A8[37] = 0.0;
    A8[148] = 0.0;
    A8[123] = 0.0;
    A8[85] = 0.0;
    A8[66] = 0.0;
    A8[160] = 0.0;
    A8[137] = 0.0;
    A8[91] = 0.0;
    A8[82] = 0.0;
    A8[168] = 0.0;
    A8[109] = 0.0;
    A8[222] = 0.0;
    A8[184] = 0.0;
    A8[213] = 0.0;
    A8[204] = 0.0;
    A8[133] = 0.0;
    A8[68] = 0.0;
    A8[45] = A8[35] - 0.0126984126984127*G8_0_0 - 0.0126984126984127*G8_0_1 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 + 0.0126984126984127*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0126984126984127*G8_5_0;
    A8[61] = A8[45] + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 + 0.0126984126984127*G8_1_0 + 0.0126984126984127*G8_3_1 - 0.0126984126984127*G8_4_1 - 0.0253968253968254*G8_5_0 - 0.0126984126984127*G8_5_1;
    A8[60] = A8[61] - 0.026984126984127*G8_0_0 - 0.026984126984127*G8_0_1 - 0.0111111111111111*G8_1_0 - 0.00476190476190475*G8_2_1 + 0.00634920634920635*G8_3_0 - 0.00634920634920635*G8_4_0 + 0.0317460317460317*G8_4_1 + 0.0380952380952381*G8_5_0;
    A8[4] = A8[60];
    A8[1] = A8[61] - 0.00436507936507936*G8_0_0 - 0.00436507936507936*G8_0_1 - 0.00833333333333333*G8_1_0 + 0.0123015873015873*G8_2_1 + 0.0206349206349206*G8_3_0 - 0.0206349206349206*G8_4_0 - 0.00793650793650794*G8_4_1 + 0.0126984126984127*G8_5_0;
    A8[46] = A8[60] + 0.0253968253968254*G8_0_0 + 0.0253968253968254*G8_0_1 + 0.0253968253968254*G8_1_0 + 0.0253968253968253*G8_3_1 - 0.0253968253968254*G8_4_1 - 0.0507936507936508*G8_5_0 - 0.0253968253968254*G8_5_1;
    A8[31] = A8[1] - 0.00793650793650793*G8_0_0 - 0.00793650793650793*G8_0_1 - 0.00793650793650793*G8_2_1 - 0.00793650793650793*G8_3_0 + 0.00793650793650793*G8_4_0 + 0.0158730158730159*G8_4_1 + 0.00793650793650793*G8_5_0;
    A8[76] = A8[46] + 0.00634920634920635*G8_0_0 + 0.00634920634920635*G8_0_1 + 0.00634920634920634*G8_2_1 + 0.00634920634920635*G8_3_0 - 0.00634920634920635*G8_4_0 - 0.0126984126984127*G8_4_1 - 0.00634920634920639*G8_5_0;
    A8[20] = A8[76];
    A8[5] = A8[76] - 0.0317460317460318*G8_0_0 - 0.0317460317460318*G8_0_1 - 0.0317460317460317*G8_1_0 - 0.0317460317460317*G8_3_1 + 0.0317460317460317*G8_4_1 + 0.0634920634920635*G8_5_0 + 0.0317460317460318*G8_5_1;
    A8[47] = A8[5] + 0.0253968253968254*G8_0_0 + 0.0253968253968254*G8_0_1 + 0.0253968253968254*G8_2_1 + 0.0253968253968254*G8_3_0 - 0.0253968253968254*G8_4_0 - 0.0507936507936508*G8_4_1 - 0.0253968253968254*G8_5_0;
    A8[15] = A8[1];
    A8[2] = A8[31] + 0.00793650793650793*G8_0_0 + 0.00793650793650793*G8_0_1 + 0.00793650793650793*G8_1_0 + 0.00793650793650792*G8_3_1 - 0.00793650793650793*G8_4_1 - 0.0158730158730159*G8_5_0 - 0.00793650793650793*G8_5_1;
    A8[18] = A8[46];
    A8[38] = 0.0;
    A8[143] = 0.0;
    A8[120] = 0.0;
    A8[88] = 0.0;
    A8[92] = 0.0;
    A8[179] = 0.0;
    A8[116] = 0.0;
    A8[219] = 0.0;
    A8[189] = 0.0;
    A8[207] = 0.0;
    A8[55] = 0.0;
    A8[29] = 0.0;
    A8[130] = 0.0;
    A8[73] = 0.0;
    A8[43] = 0.0;
    A8[146] = 0.0;
    A8[75] = A8[5];
    A8[150] = 0.0;
    A8[183] = 0.0;
    A8[178] = 0.0;
    A8[119] = 0.0;
    A8[220] = 0.0;
    A8[197] = 0.0;
    A8[194] = 0.0;
    A8[19] = A8[61];
    A8[12] = 0.0;
    A8[54] = 0.0;
    A8[33] = A8[47];
    A8[24] = 0.0;
    A8[127] = 0.0;
    A8[62] = A8[60] + 0.0317460317460318*G8_0_0 + 0.0317460317460317*G8_0_1 + 0.0317460317460317*G8_2_1 + 0.0317460317460317*G8_3_0 - 0.0317460317460317*G8_4_0 - 0.0634920634920635*G8_4_1 - 0.0317460317460318*G8_5_0;
    A8[44] = 0.0;
    A8[141] = 0.0;
    A8[95] = 0.0;
    A8[78] = A8[50];
    A8[172] = 0.0;
    A8[155] = 0.0;
    A8[105] = 0.0;
    A8[98] = 0.0;
    A8[180] = 0.0;
    A8[173] = 0.0;
    A8[118] = 0.0;
    A8[217] = 0.0;
    A8[200] = 0.0;
    A8[6] = 0.0;
    A8[22] = 0.0;
    A8[9] = 0.0;
    A8[49] = A8[65] + 0.0253968253968254*G8_0_0 + 0.0253968253968254*G8_0_1 + 0.0253968253968254*G8_2_1 + 0.0253968253968254*G8_3_0 - 0.0253968253968254*G8_4_0 - 0.0507936507936508*G8_4_1 - 0.0253968253968254*G8_5_0;
    A8[34] = A8[62];
    A8[147] = 0.0;
    A8[124] = 0.0;
    A8[84] = 0.0;
    A8[67] = 0.0;
    A8[161] = 0.0;
    A8[136] = 0.0;
    A8[96] = 0.0;
    A8[81] = 0.0;
    A8[167] = 0.0;
    A8[156] = 0.0;
    A8[112] = 0.0;
    A8[223] = 0.0;
    A8[185] = 0.0;
    A8[210] = 0.0;
    A8[203] = 0.0;
    A8[3] = A8[45];
    A8[59] = 0.0;
    A8[17] = A8[31];
    A8[134] = 0.0;
    A8[69] = 0.0;
    A8[48] = -7.99999999999999*A8[45];
    A8[39] = 0.0;
    A8[121] = 0.0;
    A8[87] = 0.0;
    A8[64] = -8.00000000000001*A8[61];
    A8[162] = 0.0;
    A8[93] = 0.0;
    A8[166] = 0.0;
    A8[115] = 0.0;
    A8[224] = 0.0;
    A8[190] = 0.0;
    A8[206] = 0.0;
    A8[0] = A8[16] - 0.0380952380952381*G8_0_0 - 0.0380952380952381*G8_0_1 - 0.0380952380952381*G8_1_0 - 0.038095238095238*G8_3_1 + 0.0380952380952381*G8_4_1 + 0.0761904761904762*G8_5_0 + 0.0380952380952381*G8_5_1;
    A8[32] = A8[0] + 0.0380952380952381*G8_0_0 + 0.0380952380952381*G8_0_1 + 0.0380952380952381*G8_2_1 + 0.038095238095238*G8_3_0 - 0.038095238095238*G8_4_0 - 0.0761904761904762*G8_4_1 - 0.0380952380952381*G8_5_0;
    A8[58] = 0.0;
    A8[28] = 0.0;
    A8[131] = 0.0;
    A8[74] = 0.0;
    A8[40] = 0.0;
    A8[145] = 0.0;
    A8[151] = 0.0;
    A8[102] = 0.0;
    A8[177] = 0.0;
    A8[114] = 0.0;
    A8[221] = 0.0;
    A8[196] = 0.0;
    A8[209] = 0.0;
    A8[13] = 0.0;
    A8[53] = 0.0;
    A8[30] = A8[2];
    A8[23] = 0.0;
    A8[128] = 0.0;
    A8[63] = A8[49];
    A8[140] = 0.0;
    A8[77] = A8[35];
    A8[171] = 0.0;
    A8[152] = 0.0;
    
    double A9[225];
    A9[108] = 0.0;
    A9[99] = 0.0;
    A9[181] = 0.0;
    A9[176] = 0.0;
    A9[117] = 0.0;
    A9[214] = 0.0;
    A9[199] = 0.0;
    A9[192] = 0.0;
    A9[7] = 0.00357142857142857*G9_0_0 + 0.00357142857142857*G9_0_1 - 0.00357142857142857*G9_1_0 + 0.00436507936507936*G9_2_1 + 0.00158730158730159*G9_3_0 - 0.00634920634920634*G9_3_1 - 0.00158730158730159*G9_4_0 - 0.00793650793650793*G9_4_1 + 0.00634920634920635*G9_5_1;
    A9[21] = A9[7];
    A9[10] = A9[7] - 0.0226190476190476*G9_0_0 - 0.0226190476190476*G9_0_1 - 0.00277777777777779*G9_1_0 - 0.0170634920634921*G9_2_1 - 0.0142857142857143*G9_3_0 + 0.0142857142857143*G9_4_0 + 0.0396825396825397*G9_4_1 + 0.0253968253968254*G9_5_0;
    A9[52] = A9[10] + 0.0253968253968254*G9_0_0 + 0.0253968253968254*G9_0_1 + 0.0253968253968254*G9_1_0 + 0.0253968253968253*G9_3_1 - 0.0253968253968254*G9_4_1 - 0.0507936507936508*G9_5_0 - 0.0253968253968254*G9_5_1;
    A9[35] = 0.0;
    A9[26] = A9[52] + 0.00634920634920635*G9_0_0 + 0.00634920634920635*G9_0_1 + 0.00634920634920634*G9_2_1 + 0.00634920634920635*G9_3_0 - 0.00634920634920635*G9_4_0 - 0.0126984126984127*G9_4_1 - 0.00634920634920639*G9_5_0;
    A9[125] = 0.0;
    A9[60] = 0.0;
    A9[158] = 0.0;
    A9[135] = 0.0;
    A9[97] = 0.0;
    A9[80] = 0.0;
    A9[170] = 0.0;
    A9[157] = 0.0;
    A9[111] = 0.0;
    A9[100] = 0.0;
    A9[186] = 0.0;
    A9[211] = 0.0;
    A9[202] = 0.0;
    A9[4] = 0.0;
    A9[16] = 0.0;
    A9[47] = 0.0;
    A9[149] = 0.0;
    A9[122] = 0.0;
    A9[65] = 0.0;
    A9[163] = 0.0;
    A9[138] = 0.0;
    A9[90] = 0.0;
    A9[165] = 0.0;
    A9[110] = 0.0;
    A9[191] = 0.0;
    A9[212] = 0.0;
    A9[205] = 0.0;
    A9[1] = 0.0;
    A9[57] = 0.0;
    A9[27] = 0.0;
    A9[132] = 0.0;
    A9[46] = 0.0;
    A9[144] = 0.0;
    A9[89] = 0.0;
    A9[164] = 0.0;
    A9[103] = 0.0;
    A9[113] = 0.0;
    A9[218] = 0.0;
    A9[195] = 0.0;
    A9[188] = 0.0;
    A9[208] = 0.0;
    A9[14] = 0.0;
    A9[56] = -A9[52] + 0.0507936507936508*G9_1_0 - 0.00634920634920633*G9_2_1 + 0.038095238095238*G9_3_0 + 0.0952380952380951*G9_3_1 - 0.038095238095238*G9_4_0 + 0.00634920634920634*G9_4_1 - 0.0507936507936508*G9_5_0 - 0.0952380952380952*G9_5_1;
    A9[31] = 0.0;
    A9[129] = 0.0;
    A9[72] = 0.0;
    A9[42] = 0.0;
    A9[139] = 0.0;
    A9[76] = 0.0;
    A9[153] = 0.0;
    A9[107] = 0.0;
    A9[104] = 0.0;
    A9[182] = 0.0;
    A9[175] = 0.0;
    A9[215] = 0.0;
    A9[198] = 0.0;
    A9[193] = 0.0;
    A9[20] = 0.0;
    A9[11] = A9[26] - 0.0317460317460318*G9_0_0 - 0.0317460317460318*G9_0_1 - 0.0317460317460317*G9_1_0 - 0.0317460317460317*G9_3_1 + 0.0317460317460317*G9_4_1 + 0.0634920634920635*G9_5_0 + 0.0317460317460318*G9_5_1;
    A9[32] = 0.0;
    A9[126] = 0.0;
    A9[61] = 0.0;
    A9[159] = 0.0;
    A9[142] = 0.0;
    A9[94] = 0.0;
    A9[79] = 0.0;
    A9[169] = 0.0;
    A9[154] = 0.0;
    A9[106] = 0.0;
    A9[101] = 0.0;
    A9[187] = 0.0;
    A9[174] = 0.0;
    A9[216] = 0.0;
    A9[201] = 0.0;
    A9[5] = 0.0;
    A9[15] = 0.0;
    A9[71] = A9[56] - 0.0253968253968254*G9_0_0 - 0.0253968253968254*G9_0_1 - 0.0253968253968254*G9_1_0 - 0.0253968253968254*G9_3_1 + 0.0253968253968254*G9_4_1 + 0.0507936507936508*G9_5_0 + 0.0253968253968254*G9_5_1;
    A9[50] = 0.0;
    A9[37] = A9[7] - 0.00793650793650793*G9_0_0 - 0.00793650793650793*G9_0_1 - 0.00793650793650793*G9_2_1 - 0.00793650793650793*G9_3_0 + 0.00793650793650793*G9_4_0 + 0.0158730158730159*G9_4_1 + 0.00793650793650793*G9_5_0;
    A9[83] = A9[37] + 0.0123015873015873*G9_0_0 + 0.0123015873015873*G9_0_1 - 0.00436507936507937*G9_1_0 + 0.00833333333333333*G9_2_1 - 0.0126984126984127*G9_3_1 - 0.0206349206349206*G9_4_1 - 0.00793650793650792*G9_5_0 + 0.0126984126984127*G9_5_1;
    A9[36] = A9[37] + 0.00793650793650793*G9_0_0 + 0.00793650793650793*G9_0_1 + 0.00793650793650793*G9_1_0 + 0.00793650793650792*G9_3_1 - 0.00793650793650793*G9_4_1 - 0.0158730158730159*G9_5_0 - 0.00793650793650793*G9_5_1;
    A9[86] = -8.00000000000001*A9[83];
    A9[41] = A9[83];
    A9[51] = A9[83] - 0.0126984126984127*G9_0_0 - 0.0126984126984127*G9_0_1 - 0.0126984126984127*G9_2_1 - 0.0126984126984127*G9_3_0 + 0.0126984126984127*G9_4_0 + 0.0253968253968254*G9_4_1 + 0.0126984126984127*G9_5_0;
    A9[8] = A9[36];
    A9[148] = 0.0;
    A9[123] = 0.0;
    A9[85] = A9[71];
    A9[66] = A9[10];
    A9[160] = 0.0;
    A9[137] = 0.0;
    A9[91] = 0.0;
    A9[82] = A9[26];
    A9[168] = 0.0;
    A9[109] = 0.0;
    A9[222] = 0.0;
    A9[184] = 0.0;
    A9[213] = 0.0;
    A9[204] = 0.0;
    A9[2] = 0.0;
    A9[18] = 0.0;
    A9[133] = 0.0;
    A9[68] = A9[10] + 0.0317460317460318*G9_0_0 + 0.0317460317460317*G9_0_1 + 0.0317460317460317*G9_2_1 + 0.0317460317460317*G9_3_0 - 0.0317460317460317*G9_4_0 - 0.0634920634920635*G9_4_1 - 0.0317460317460318*G9_5_0;
    A9[45] = 0.0;
    A9[38] = 0.00714285714285714*G9_0_0 + 0.00714285714285713*G9_0_1 - 0.00714285714285714*G9_1_0 + 0.0309523809523809*G9_2_1 + 0.0476190476190475*G9_3_0 + 0.0095238095238095*G9_3_1 - 0.0476190476190475*G9_4_0 - 0.038095238095238*G9_4_1 - 0.00952380952380951*G9_5_1;
    A9[143] = 0.0;
    A9[120] = 0.0;
    A9[88] = 0.0;
    A9[92] = 0.0;
    A9[179] = 0.0;
    A9[116] = 0.0;
    A9[219] = 0.0;
    A9[189] = 0.0;
    A9[207] = 0.0;
    A9[55] = A9[71] + 0.0253968253968254*G9_0_0 + 0.0253968253968254*G9_0_1 + 0.0253968253968254*G9_2_1 + 0.0253968253968254*G9_3_0 - 0.0253968253968254*G9_4_0 - 0.0507936507936508*G9_4_1 - 0.0253968253968254*G9_5_0;
    A9[29] = 0.0;
    A9[130] = 0.0;
    A9[73] = 0.0;
    A9[43] = 0.0;
    A9[146] = 0.0;
    A9[75] = 0.0;
    A9[150] = 0.0;
    A9[183] = 0.0;
    A9[178] = 0.0;
    A9[119] = 0.0;
    A9[220] = 0.0;
    A9[197] = 0.0;
    A9[194] = 0.0;
    A9[19] = 0.0;
    A9[12] = 0.0;
    A9[54] = -7.99999999999999*A9[51];
    A9[70] = A9[54] - 0.101587301587302*G9_0_0 - 0.101587301587302*G9_0_1 - 0.101587301587302*G9_1_0 - 0.101587301587301*G9_3_1 + 0.101587301587301*G9_4_1 + 0.203174603174603*G9_5_0 + 0.101587301587302*G9_5_1;
    A9[25] = -0.125*A9[70];
    A9[33] = 0.0;
    A9[24] = A9[52];
    A9[127] = 0.0;
    A9[62] = 0.0;
    A9[44] = 0.0;
    A9[141] = 0.0;
    A9[95] = 0.0;
    A9[78] = 0.0;
    A9[172] = 0.0;
    A9[155] = 0.0;
    A9[105] = 0.0;
    A9[98] = 0.0;
    A9[180] = 0.0;
    A9[173] = 0.0;
    A9[118] = 0.0;
    A9[217] = 0.0;
    A9[200] = 0.0;
    A9[6] = A9[38] - 0.0380952380952381*G9_0_0 - 0.0380952380952381*G9_0_1 - 0.0380952380952381*G9_2_1 - 0.038095238095238*G9_3_0 + 0.038095238095238*G9_4_0 + 0.0761904761904762*G9_4_1 + 0.0380952380952381*G9_5_0;
    A9[22] = A9[6] + 0.0380952380952381*G9_0_0 + 0.0380952380952381*G9_0_1 + 0.0380952380952381*G9_1_0 + 0.038095238095238*G9_3_1 - 0.0380952380952381*G9_4_1 - 0.0761904761904762*G9_5_0 - 0.0380952380952381*G9_5_1;
    A9[9] = A9[51];
    A9[49] = 0.0;
    A9[34] = 0.0;
    A9[147] = 0.0;
    A9[124] = 0.0;
    A9[84] = A9[56];
    A9[67] = A9[25];
    A9[161] = 0.0;
    A9[136] = 0.0;
    A9[96] = 0.0;
    A9[81] = A9[11];
    A9[167] = 0.0;
    A9[156] = 0.0;
    A9[112] = 0.0;
    A9[223] = 0.0;
    A9[185] = 0.0;
    A9[210] = 0.0;
    A9[203] = 0.0;
    A9[3] = 0.0;
    A9[59] = 0.0;
    A9[17] = 0.0;
    A9[134] = 0.0;
    A9[69] = A9[55];
    A9[48] = 0.0;
    A9[39] = A9[11] + 0.0253968253968254*G9_0_0 + 0.0253968253968254*G9_0_1 + 0.0253968253968254*G9_2_1 + 0.0253968253968254*G9_3_0 - 0.0253968253968254*G9_4_0 - 0.0507936507936508*G9_4_1 - 0.0253968253968254*G9_5_0;
    A9[121] = 0.0;
    A9[87] = 0.0;
    A9[64] = 0.0;
    A9[162] = 0.0;
    A9[93] = 0.0;
    A9[166] = 0.0;
    A9[115] = 0.0;
    A9[224] = 0.0;
    A9[190] = 0.0;
    A9[206] = 0.0;
    A9[0] = 0.0;
    A9[58] = 0.0;
    A9[28] = 0.0;
    A9[131] = 0.0;
    A9[74] = 0.0;
    A9[40] = A9[68];
    A9[145] = 0.0;
    A9[151] = 0.0;
    A9[102] = 0.0;
    A9[177] = 0.0;
    A9[114] = 0.0;
    A9[221] = 0.0;
    A9[196] = 0.0;
    A9[209] = 0.0;
    A9[13] = 0.0;
    A9[53] = A9[39];
    A9[30] = 0.0;
    A9[23] = A9[37];
    A9[128] = 0.0;
    A9[63] = 0.0;
    A9[140] = 0.0;
    A9[77] = 0.0;
    A9[171] = 0.0;
    A9[152] = 0.0;
    
    double A10[225];
    A10[108] = 0.00634920634920634*G10_6_0 + 0.00634920634920634*G10_6_1 + 0.019047619047619*G10_7_0 - 0.0126984126984127*G10_8_1 - 0.0126984126984127*G10_9_0 + 0.019047619047619*G10_9_1 + 0.0126984126984127*G10_10_0 + 0.00634920634920636*G10_10_1 - 0.0253968253968254*G10_11_0 - 0.019047619047619*G10_11_1;
    A10[99] = 0.0;
    A10[181] = 0.0;
    A10[176] = 0.0;
    A10[117] = 0.0;
    A10[214] = 0.0;
    A10[199] = 0.0;
    A10[192] = 0.0;
    A10[7] = 0.0;
    A10[21] = 0.0;
    A10[10] = 0.0;
    A10[52] = 0.0;
    A10[35] = 0.0;
    A10[26] = 0.0;
    A10[125] = -A10[108] + 0.0142857142857143*G10_6_0 + 0.0142857142857143*G10_6_1 + 0.0111111111111111*G10_7_0 - 0.00793650793650793*G10_8_1 - 0.019047619047619*G10_9_0 + 0.019047619047619*G10_10_0 - 0.00634920634920633*G10_10_1 - 0.0253968253968253*G10_11_0;
    A10[83] = 0.0;
    A10[60] = 0.0;
    A10[158] = 0.0;
    A10[135] = A10[125] - 0.0126984126984127*G10_6_0 - 0.0126984126984127*G10_6_1 - 0.0126984126984127*G10_8_1 - 0.0126984126984127*G10_9_0 + 0.0126984126984127*G10_10_0 + 0.0253968253968254*G10_10_1 + 0.0126984126984127*G10_11_0;
    A10[97] = 0.0;
    A10[80] = 0.0;
    A10[170] = -8.00000000000001*A10[125];
    A10[157] = 0.0;
    A10[111] = 0.0;
    A10[100] = 0.0;
    A10[186] = 0.0;
    A10[211] = 0.0;
    A10[202] = 0.0;
    A10[4] = 0.0;
    A10[16] = 0.0;
    A10[70] = 0.0;
    A10[47] = 0.0;
    A10[36] = 0.0;
    A10[149] = 0.0;
    A10[122] = 0.00714285714285714*G10_6_0 + 0.00714285714285713*G10_6_1 - 0.00714285714285714*G10_7_0 + 0.0309523809523809*G10_8_1 + 0.0476190476190475*G10_9_0 + 0.0095238095238095*G10_9_1 - 0.0476190476190475*G10_10_0 - 0.038095238095238*G10_10_1 - 0.00952380952380951*G10_11_1;
    A10[86] = 0.0;
    A10[65] = 0.0;
    A10[163] = 0.0;
    A10[138] = -7.99999999999999*A10[135];
    A10[90] = A10[122] - 0.0380952380952381*G10_6_0 - 0.0380952380952381*G10_6_1 - 0.0380952380952381*G10_8_1 - 0.038095238095238*G10_9_0 + 0.038095238095238*G10_10_0 + 0.0761904761904762*G10_10_1 + 0.0380952380952381*G10_11_0;
    A10[110] = A10[108] + 0.00634920634920635*G10_6_0 + 0.00634920634920635*G10_6_1 + 0.00634920634920634*G10_8_1 + 0.00634920634920636*G10_9_0 - 0.00634920634920636*G10_10_0 - 0.0126984126984127*G10_10_1 - 0.00634920634920639*G10_11_0;
    A10[165] = A10[110] - 0.0317460317460318*G10_6_0 - 0.0317460317460318*G10_6_1 - 0.0317460317460317*G10_7_0 - 0.0317460317460317*G10_9_1 + 0.0317460317460317*G10_10_1 + 0.0634920634920635*G10_11_0 + 0.0317460317460318*G10_11_1;
    A10[191] = 0.0;
    A10[212] = 0.0;
    A10[205] = 0.0;
    A10[1] = 0.0;
    A10[57] = 0.0;
    A10[27] = 0.0;
    A10[132] = 0.0;
    A10[46] = 0.0;
    A10[41] = 0.0;
    A10[144] = 0.0;
    A10[89] = 0.0;
    A10[164] = 0.0;
    A10[103] = 0.0;
    A10[113] = 0.0;
    A10[218] = 0.0;
    A10[195] = 0.0;
    A10[188] = 0.0;
    A10[208] = 0.0;
    A10[14] = 0.0;
    A10[56] = 0.0;
    A10[31] = 0.0;
    A10[129] = 0.0;
    A10[72] = 0.0;
    A10[42] = 0.0;
    A10[139] = -A10[108] + 0.0253968253968254*G10_7_0 + 0.019047619047619*G10_8_1 + 0.0634920634920634*G10_9_0 + 0.0698412698412697*G10_9_1 - 0.0634920634920634*G10_10_0 - 0.019047619047619*G10_10_1 - 0.0253968253968254*G10_11_0 - 0.0698412698412698*G10_11_1;
    A10[76] = 0.0;
    A10[153] = A10[139];
    A10[107] = A10[110] - 0.0170634920634921*G10_6_0 - 0.0170634920634921*G10_6_1 - 0.0226190476190476*G10_7_0 + 0.00277777777777779*G10_8_1 - 0.0253968253968254*G10_9_1 + 0.0142857142857143*G10_10_1 + 0.0396825396825397*G10_11_0 + 0.0253968253968254*G10_11_1;
    A10[104] = 0.0;
    A10[182] = 0.0;
    A10[175] = 0.0;
    A10[215] = 0.0;
    A10[198] = 0.0;
    A10[193] = 0.0;
    A10[20] = 0.0;
    A10[11] = 0.0;
    A10[51] = 0.0;
    A10[32] = 0.0;
    A10[25] = 0.0;
    A10[126] = 0.0;
    A10[61] = 0.0;
    A10[159] = 0.0;
    A10[142] = 0.0;
    A10[94] = A10[108] - 0.0253968253968254*G10_6_0 - 0.0253968253968254*G10_6_1 - 0.0253968253968254*G10_7_0 - 0.0253968253968253*G10_9_1 + 0.0253968253968254*G10_10_1 + 0.0507936507936508*G10_11_0 + 0.0253968253968254*G10_11_1;
    A10[79] = 0.0;
    A10[169] = A10[139] - 0.0253968253968254*G10_6_0 - 0.0253968253968254*G10_6_1 - 0.0253968253968254*G10_8_1 - 0.0253968253968254*G10_9_0 + 0.0253968253968254*G10_10_0 + 0.0507936507936508*G10_10_1 + 0.0253968253968254*G10_11_0;
    A10[154] = A10[138] - 0.101587301587302*G10_6_0 - 0.101587301587302*G10_6_1 - 0.101587301587302*G10_7_0 - 0.101587301587301*G10_9_1 + 0.101587301587301*G10_10_1 + 0.203174603174603*G10_11_0 + 0.101587301587302*G10_11_1;
    A10[106] = A10[90] + 0.0380952380952381*G10_6_0 + 0.0380952380952381*G10_6_1 + 0.0380952380952381*G10_7_0 + 0.038095238095238*G10_9_1 - 0.0380952380952381*G10_10_1 - 0.0761904761904762*G10_11_0 - 0.0380952380952381*G10_11_1;
    A10[101] = 0.0;
    A10[187] = 0.0;
    A10[174] = 0.0;
    A10[216] = 0.0;
    A10[201] = 0.0;
    A10[5] = 0.0;
    A10[15] = 0.0;
    A10[8] = 0.0;
    A10[71] = 0.0;
    A10[50] = 0.0;
    A10[37] = 0.0;
    A10[148] = 0.0;
    A10[123] = A10[165] + 0.0253968253968254*G10_6_0 + 0.0253968253968254*G10_6_1 + 0.0253968253968254*G10_8_1 + 0.0253968253968254*G10_9_0 - 0.0253968253968254*G10_10_0 - 0.0507936507936508*G10_10_1 - 0.0253968253968254*G10_11_0;
    A10[85] = 0.0;
    A10[66] = 0.0;
    A10[160] = 0.0;
    A10[137] = A10[123];
    A10[91] = A10[107] + 0.00793650793650793*G10_6_0 + 0.00793650793650793*G10_6_1 + 0.00793650793650793*G10_8_1 + 0.00793650793650792*G10_9_0 - 0.00793650793650792*G10_10_0 - 0.0158730158730159*G10_10_1 - 0.00793650793650793*G10_11_0;
    A10[82] = 0.0;
    A10[168] = A10[169] + 0.0253968253968254*G10_6_0 + 0.0253968253968254*G10_6_1 + 0.0253968253968254*G10_7_0 + 0.0253968253968254*G10_9_1 - 0.0253968253968254*G10_10_1 - 0.0507936507936508*G10_11_0 - 0.0253968253968254*G10_11_1;
    A10[109] = -0.125*A10[154];
    A10[222] = 0.0;
    A10[184] = 0.0;
    A10[213] = 0.0;
    A10[204] = 0.0;
    A10[2] = 0.0;
    A10[18] = 0.0;
    A10[133] = 0.0;
    A10[68] = 0.0;
    A10[45] = 0.0;
    A10[38] = 0.0;
    A10[143] = 0.0;
    A10[120] = A10[107] + 0.00793650793650793*G10_6_0 + 0.00793650793650793*G10_6_1 + 0.00793650793650793*G10_7_0 + 0.00793650793650792*G10_9_1 - 0.00793650793650793*G10_10_1 - 0.0158730158730159*G10_11_0 - 0.00793650793650793*G10_11_1;
    A10[88] = 0.0;
    A10[92] = A10[120];
    A10[179] = 0.0;
    A10[116] = 0.0;
    A10[219] = 0.0;
    A10[189] = 0.0;
    A10[207] = 0.0;
    A10[55] = 0.0;
    A10[29] = 0.0;
    A10[130] = 0.0;
    A10[73] = 0.0;
    A10[43] = 0.0;
    A10[146] = 0.0;
    A10[75] = 0.0;
    A10[150] = A10[94];
    A10[183] = 0.0;
    A10[178] = 0.0;
    A10[119] = 0.0;
    A10[220] = 0.0;
    A10[197] = 0.0;
    A10[194] = 0.0;
    A10[19] = 0.0;
    A10[12] = 0.0;
    A10[54] = 0.0;
    A10[33] = 0.0;
    A10[24] = 0.0;
    A10[127] = 0.0;
    A10[62] = 0.0;
    A10[44] = 0.0;
    A10[141] = 0.0;
    A10[95] = A10[165];
    A10[78] = 0.0;
    A10[172] = 0.0;
    A10[155] = A10[169];
    A10[105] = A10[91];
    A10[98] = 0.0;
    A10[180] = 0.0;
    A10[173] = 0.0;
    A10[118] = 0.0;
    A10[217] = 0.0;
    A10[200] = 0.0;
    A10[6] = 0.0;
    A10[22] = 0.0;
    A10[9] = 0.0;
    A10[49] = 0.0;
    A10[34] = 0.0;
    A10[147] = 0.0;
    A10[124] = A10[94] + 0.0317460317460318*G10_6_0 + 0.0317460317460317*G10_6_1 + 0.0317460317460317*G10_8_1 + 0.0317460317460317*G10_9_0 - 0.0317460317460317*G10_10_0 - 0.0634920634920635*G10_10_1 - 0.0317460317460318*G10_11_0;
    A10[84] = 0.0;
    A10[67] = 0.0;
    A10[161] = 0.0;
    A10[136] = A10[108];
    A10[96] = 0.0;
    A10[81] = 0.0;
    A10[167] = A10[125];
    A10[156] = 0.0;
    A10[112] = 0.0;
    A10[223] = 0.0;
    A10[185] = 0.0;
    A10[210] = 0.0;
    A10[203] = 0.0;
    A10[3] = 0.0;
    A10[59] = 0.0;
    A10[17] = 0.0;
    A10[134] = 0.0;
    A10[69] = 0.0;
    A10[48] = 0.0;
    A10[39] = 0.0;
    A10[121] = A10[107];
    A10[87] = 0.0;
    A10[64] = 0.0;
    A10[162] = 0.0;
    A10[93] = A10[135];
    A10[166] = A10[110];
    A10[115] = 0.0;
    A10[224] = 0.0;
    A10[190] = 0.0;
    A10[206] = 0.0;
    A10[0] = 0.0;
    A10[58] = 0.0;
    A10[28] = 0.0;
    A10[131] = 0.0;
    A10[74] = 0.0;
    A10[40] = 0.0;
    A10[145] = 0.0;
    A10[151] = A10[109];
    A10[102] = 0.0;
    A10[177] = 0.0;
    A10[114] = 0.0;
    A10[221] = 0.0;
    A10[196] = 0.0;
    A10[209] = 0.0;
    A10[13] = 0.0;
    A10[53] = 0.0;
    A10[30] = 0.0;
    A10[23] = 0.0;
    A10[128] = 0.0;
    A10[63] = 0.0;
    A10[140] = A10[168];
    A10[77] = 0.0;
    A10[171] = 0.0;
    A10[152] = A10[124];
    
    double A11[225];
    A11[108] = 0.0;
    A11[181] = 0.0;
    A11[176] = -0.0634920634920635*G11_6_0 - 0.0634920634920635*G11_6_1 + 0.0634920634920635*G11_7_0 - 0.0380952380952381*G11_8_1 + 0.0507936507936507*G11_9_0 + 0.152380952380952*G11_9_1 - 0.0507936507936507*G11_10_0 + 0.101587301587302*G11_10_1 - 0.152380952380952*G11_11_1;
    A11[117] = 0.0;
    A11[214] = 0.0;
    A11[199] = 0.0;
    A11[192] = 0.0;
    A11[7] = 0.0;
    A11[21] = 0.0;
    A11[10] = 0.0;
    A11[52] = 0.0;
    A11[35] = 0.0;
    A11[26] = 0.0;
    A11[125] = 0.0;
    A11[83] = 0.0;
    A11[60] = 0.0;
    A11[135] = 0.0;
    A11[80] = 0.0;
    A11[170] = 0.0;
    A11[186] = 0.0;
    A11[211] = 0.0;
    A11[202] = 0.0;
    A11[4] = 0.0;
    A11[16] = 0.0;
    A11[70] = 0.0;
    A11[47] = 0.0;
    A11[36] = 0.0;
    A11[149] = 0.0;
    A11[122] = 0.0;
    A11[86] = 0.0;
    A11[65] = 0.0;
    A11[163] = 0.0;
    A11[138] = 0.0;
    A11[90] = 0.0;
    A11[165] = 0.0;
    A11[110] = 0.0;
    A11[191] = 0.0;
    A11[212] = 0.0;
    A11[205] = 0.0;
    A11[1] = 0.0;
    A11[57] = 0.0;
    A11[27] = 0.0;
    A11[132] = 0.0;
    A11[46] = 0.0;
    A11[41] = 0.0;
    A11[89] = 0.0;
    A11[164] = 0.0;
    A11[103] = 0.0;
    A11[218] = 0.0;
    A11[195] = 0.0;
    A11[188] = 0.0;
    A11[208] = 0.0;
    A11[14] = 0.0;
    A11[56] = 0.0;
    A11[31] = 0.0;
    A11[72] = 0.0;
    A11[42] = 0.0;
    A11[139] = 0.0;
    A11[76] = 0.0;
    A11[153] = 0.0;
    A11[107] = 0.0;
    A11[104] = 0.0;
    A11[182] = 0.0;
    A11[175] = A11[176] + 0.0317460317460317*G11_6_0 + 0.0317460317460317*G11_6_1 - 0.0571428571428572*G11_7_0 + 0.0444444444444444*G11_8_1 - 0.101587301587302*G11_9_1 - 0.0761904761904762*G11_10_1 + 0.0253968253968254*G11_11_0 + 0.101587301587302*G11_11_1;
    A11[215] = 0.0;
    A11[198] = 0.0;
    A11[193] = 0.0;
    A11[20] = 0.0;
    A11[11] = 0.0;
    A11[51] = 0.0;
    A11[32] = 0.0;
    A11[25] = 0.0;
    A11[61] = 0.0;
    A11[159] = A11[175] + 0.0253968253968254*G11_6_0 + 0.0253968253968254*G11_6_1 + 0.0253968253968254*G11_8_1 + 0.0253968253968254*G11_9_0 - 0.0253968253968254*G11_10_0 - 0.0507936507936508*G11_10_1 - 0.0253968253968254*G11_11_0;
    A11[94] = 0.0;
    A11[79] = 0.0;
    A11[169] = 0.0;
    A11[154] = 0.0;
    A11[106] = 0.0;
    A11[187] = 0.0;
    A11[174] = A11[175] + 0.0253968253968254*G11_6_0 + 0.0253968253968254*G11_6_1 + 0.0253968253968254*G11_7_0 + 0.0253968253968254*G11_9_1 - 0.0253968253968254*G11_10_1 - 0.0507936507936508*G11_11_0 - 0.0253968253968254*G11_11_1;
    A11[216] = 0.0;
    A11[201] = 0.0;
    A11[5] = 0.0;
    A11[15] = 0.0;
    A11[8] = 0.0;
    A11[71] = 0.0;
    A11[50] = 0.0;
    A11[37] = 0.0;
    A11[148] = 0.0;
    A11[123] = 0.0;
    A11[85] = 0.0;
    A11[66] = 0.0;
    A11[137] = 0.0;
    A11[91] = 0.0;
    A11[82] = 0.0;
    A11[168] = 0.0;
    A11[109] = 0.0;
    A11[222] = 0.0;
    A11[184] = 0.0;
    A11[213] = 0.0;
    A11[204] = 0.0;
    A11[2] = 0.0;
    A11[18] = 0.0;
    A11[133] = 0.0;
    A11[68] = 0.0;
    A11[45] = 0.0;
    A11[38] = 0.0;
    A11[120] = 0.0;
    A11[88] = 0.0;
    A11[92] = 0.0;
    A11[179] = 0.0;
    A11[219] = 0.0;
    A11[189] = 0.0;
    A11[207] = 0.0;
    A11[55] = 0.0;
    A11[29] = 0.0;
    A11[73] = 0.0;
    A11[43] = 0.0;
    A11[146] = A11[174];
    A11[75] = 0.0;
    A11[150] = 0.0;
    A11[183] = 0.0;
    A11[178] = 0.0;
    A11[119] = 0.0;
    A11[220] = 0.0;
    A11[197] = 0.0;
    A11[194] = 0.0;
    A11[19] = 0.0;
    A11[12] = 0.0;
    A11[54] = 0.0;
    A11[33] = 0.0;
    A11[24] = 0.0;
    A11[62] = 0.0;
    A11[44] = 0.0;
    A11[95] = 0.0;
    A11[78] = 0.0;
    A11[155] = 0.0;
    A11[105] = 0.0;
    A11[180] = 0.0;
    A11[173] = -0.125*A11[176];
    A11[99] = A11[173] - 0.0126984126984127*G11_6_0 - 0.0126984126984127*G11_6_1 - 0.0126984126984127*G11_8_1 - 0.0126984126984127*G11_9_0 + 0.0126984126984127*G11_10_0 + 0.0253968253968254*G11_10_1 + 0.0126984126984127*G11_11_0;
    A11[158] = -A11[99] + 0.00793650793650793*G11_6_0 + 0.00793650793650792*G11_6_1 - 0.0142857142857143*G11_7_0 + 0.0111111111111111*G11_8_1 - 0.0253968253968254*G11_9_1 - 0.019047619047619*G11_10_1 + 0.00634920634920635*G11_11_0 + 0.0253968253968254*G11_11_1;
    A11[157] = A11[99] + 0.0126984126984127*G11_6_0 + 0.0126984126984127*G11_6_1 + 0.0126984126984127*G11_7_0 + 0.0126984126984127*G11_9_1 - 0.0126984126984127*G11_10_1 - 0.0253968253968254*G11_11_0 - 0.0126984126984127*G11_11_1;
    A11[97] = A11[157] - 0.00436507936507936*G11_6_0 - 0.00436507936507936*G11_6_1 - 0.00833333333333333*G11_7_0 + 0.0123015873015873*G11_8_1 + 0.0206349206349206*G11_9_0 - 0.0206349206349206*G11_10_0 - 0.00793650793650794*G11_10_1 + 0.0126984126984127*G11_11_0;
    A11[111] = A11[97];
    A11[100] = A11[158] - 0.0317460317460318*G11_6_0 - 0.0317460317460317*G11_6_1 - 0.0317460317460317*G11_8_1 - 0.0317460317460317*G11_9_0 + 0.0317460317460317*G11_10_0 + 0.0634920634920635*G11_10_1 + 0.0317460317460318*G11_11_0;
    A11[144] = -7.99999999999999*A11[99];
    A11[113] = A11[97] - 0.00793650793650793*G11_6_0 - 0.00793650793650793*G11_6_1 - 0.00793650793650793*G11_8_1 - 0.00793650793650792*G11_9_0 + 0.00793650793650792*G11_10_0 + 0.0158730158730159*G11_10_1 + 0.00793650793650793*G11_11_0;
    A11[129] = A11[158] - 0.00634920634920635*G11_6_0 - 0.00634920634920635*G11_6_1 - 0.00634920634920634*G11_7_0 - 0.00634920634920634*G11_9_1 + 0.00634920634920636*G11_10_1 + 0.0126984126984127*G11_11_0 + 0.00634920634920634*G11_11_1;
    A11[126] = A11[113] + 0.00793650793650793*G11_6_0 + 0.00793650793650793*G11_6_1 + 0.00793650793650793*G11_7_0 + 0.00793650793650792*G11_9_1 - 0.00793650793650793*G11_10_1 - 0.0158730158730159*G11_11_0 - 0.00793650793650793*G11_11_1;
    A11[142] = A11[100] + 0.0253968253968254*G11_6_0 + 0.0253968253968254*G11_6_1 + 0.0253968253968254*G11_7_0 + 0.0253968253968253*G11_9_1 - 0.0253968253968254*G11_10_1 - 0.0507936507936508*G11_11_0 - 0.0253968253968254*G11_11_1;
    A11[101] = A11[129] - 0.0253968253968254*G11_6_0 - 0.0253968253968254*G11_6_1 - 0.0253968253968254*G11_8_1 - 0.0253968253968254*G11_9_0 + 0.0253968253968254*G11_10_0 + 0.0507936507936508*G11_10_1 + 0.0253968253968254*G11_11_0;
    A11[160] = -8.00000000000001*A11[157];
    A11[143] = A11[129];
    A11[116] = A11[142] + 0.00634920634920635*G11_6_0 + 0.00634920634920635*G11_6_1 + 0.00634920634920634*G11_8_1 + 0.00634920634920635*G11_9_0 - 0.00634920634920635*G11_10_0 - 0.0126984126984127*G11_10_1 - 0.00634920634920639*G11_11_0;
    A11[130] = A11[158];
    A11[127] = A11[113];
    A11[141] = A11[99];
    A11[172] = A11[116];
    A11[98] = A11[126];
    A11[118] = 0.0;
    A11[217] = 0.0;
    A11[200] = 0.0;
    A11[6] = 0.0;
    A11[22] = 0.0;
    A11[9] = 0.0;
    A11[49] = 0.0;
    A11[34] = 0.0;
    A11[147] = 0.0;
    A11[124] = 0.0;
    A11[84] = 0.0;
    A11[67] = 0.0;
    A11[161] = A11[175];
    A11[136] = 0.0;
    A11[81] = 0.0;
    A11[167] = 0.0;
    A11[156] = A11[100];
    A11[112] = 0.00714285714285713*G11_6_0 + 0.00714285714285714*G11_6_1 + 0.0309523809523809*G11_7_0 - 0.00714285714285713*G11_8_1 + 0.0095238095238095*G11_9_0 + 0.0476190476190476*G11_9_1 - 0.0095238095238095*G11_10_0 - 0.0380952380952381*G11_11_0 - 0.0476190476190476*G11_11_1;
    A11[96] = A11[112] - 0.0380952380952381*G11_6_0 - 0.0380952380952381*G11_6_1 - 0.0380952380952381*G11_7_0 - 0.038095238095238*G11_9_1 + 0.0380952380952381*G11_10_1 + 0.0761904761904762*G11_11_0 + 0.0380952380952381*G11_11_1;
    A11[223] = 0.0;
    A11[185] = 0.0;
    A11[210] = 0.0;
    A11[203] = 0.0;
    A11[3] = 0.0;
    A11[59] = 0.0;
    A11[17] = 0.0;
    A11[134] = 0.0;
    A11[69] = 0.0;
    A11[48] = 0.0;
    A11[39] = 0.0;
    A11[121] = 0.0;
    A11[87] = 0.0;
    A11[64] = 0.0;
    A11[162] = 0.0;
    A11[93] = 0.0;
    A11[166] = 0.0;
    A11[115] = A11[157];
    A11[224] = 0.0;
    A11[190] = 0.0;
    A11[206] = 0.0;
    A11[0] = 0.0;
    A11[58] = 0.0;
    A11[28] = 0.0;
    A11[131] = A11[173];
    A11[74] = 0.0;
    A11[40] = 0.0;
    A11[145] = A11[159];
    A11[151] = 0.0;
    A11[102] = 0.0;
    A11[177] = 0.0;
    A11[114] = A11[142];
    A11[221] = 0.0;
    A11[196] = 0.0;
    A11[209] = 0.0;
    A11[13] = 0.0;
    A11[53] = 0.0;
    A11[30] = 0.0;
    A11[23] = 0.0;
    A11[128] = A11[96] + 0.0380952380952381*G11_6_0 + 0.0380952380952381*G11_6_1 + 0.0380952380952381*G11_8_1 + 0.038095238095238*G11_9_0 - 0.038095238095238*G11_10_0 - 0.0761904761904762*G11_10_1 - 0.0380952380952381*G11_11_0;
    A11[63] = 0.0;
    A11[140] = 0.0;
    A11[77] = 0.0;
    A11[171] = A11[101];
    A11[152] = 0.0;
    
    double A12[225];
    A12[108] = 0.0;
    A12[99] = 0.0;
    A12[181] = 0.0;
    A12[176] = 0.0;
    A12[117] = 0.0;
    A12[214] = 0.0;
    A12[199] = 0.0;
    A12[192] = 0.0;
    A12[7] = 0.0;
    A12[21] = 0.0;
    A12[10] = 0.0;
    A12[52] = 0.0;
    A12[26] = 0.0;
    A12[125] = 0.0;
    A12[83] = 0.0;
    A12[158] = 0.0;
    A12[135] = 0.0;
    A12[97] = 0.0;
    A12[170] = 0.0;
    A12[157] = 0.0;
    A12[111] = 0.0;
    A12[100] = 0.0;
    A12[186] = 0.0;
    A12[211] = 0.0;
    A12[202] = 0.0;
    A12[16] = -0.00357142857142857*G12_0_0 + 0.0309523809523809*G12_1_0 - 0.00357142857142856*G12_2_0 + 0.019047619047619*G12_3_0 + 0.00476190476190476*G12_4_0 + 0.019047619047619*G12_5_0;
    A12[70] = 0.0;
    A12[47] = -0.00793650793650793*G12_0_1 - 0.0126984126984127*G12_1_1 + 0.019047619047619*G12_2_1 + 0.0634920634920634*G12_3_1 + 0.0317460317460317*G12_4_1 + 0.00634920634920636*G12_5_1;
    A12[80] = A12[47] + 0.0317460317460318*G12_0_0 + 0.0206349206349206*G12_0_1 - 0.0317460317460317*G12_1_0 - 0.00634920634920636*G12_1_1 - 0.0253968253968254*G12_3_0 - 0.13968253968254*G12_3_1 + 0.0253968253968254*G12_4_0 - 0.0825396825396825*G12_4_1 - 0.158730158730159*G12_5_1;
    A12[36] = 0.0;
    A12[149] = 0.0;
    A12[122] = 0.0;
    A12[86] = 0.0;
    A12[163] = 0.0;
    A12[138] = 0.0;
    A12[90] = 0.0;
    A12[165] = 0.0;
    A12[110] = 0.0;
    A12[191] = 0.0;
    A12[212] = 0.0;
    A12[205] = 0.0;
    A12[1] = -0.00714285714285715*G12_0_0 - 0.00357142857142857*G12_1_0 + 0.00436507936507936*G12_2_0 - 0.00793650793650793*G12_3_0 - 0.00634920634920636*G12_4_0 - 0.0126984126984127*G12_5_0;
    A12[57] = 0.0;
    A12[27] = 0.0;
    A12[132] = 0.0;
    A12[46] = -A12[1] - 0.0150793650793651*G12_0_0 + 0.0154761904761905*G12_1_0 - 0.00833333333333332*G12_2_0 + 0.0555555555555555*G12_3_0 + 0.019047619047619*G12_5_0;
    A12[41] = 0.0;
    A12[144] = 0.0;
    A12[89] = 0.0;
    A12[164] = 0.0;
    A12[103] = 0.0;
    A12[113] = 0.0;
    A12[218] = 0.0;
    A12[195] = 0.0;
    A12[188] = 0.0;
    A12[208] = 0.0;
    A12[14] = 0.0;
    A12[56] = 0.0;
    A12[31] = A12[1] + 0.0115079365079365*G12_0_0 - 0.0115079365079365*G12_2_0 - 0.00476190476190476*G12_3_0 + 0.00476190476190476*G12_5_0;
    A12[129] = 0.0;
    A12[72] = 0.0;
    A12[42] = 0.0;
    A12[139] = 0.0;
    A12[76] = A12[46] - 0.00476190476190477*G12_0_0 + 0.00476190476190476*G12_2_0 - 0.0317460317460317*G12_3_0 + 0.0317460317460318*G12_5_0;
    A12[153] = 0.0;
    A12[107] = 0.0;
    A12[104] = 0.0;
    A12[182] = 0.0;
    A12[175] = 0.0;
    A12[215] = 0.0;
    A12[198] = 0.0;
    A12[193] = 0.0;
    A12[11] = 0.0;
    A12[51] = 0.0;
    A12[32] = -0.00357142857142857*G12_0_1 - 0.00357142857142857*G12_1_1 + 0.0309523809523809*G12_2_1 + 0.019047619047619*G12_3_1 + 0.019047619047619*G12_4_1 + 0.00476190476190476*G12_5_1;
    A12[25] = 0.0;
    A12[126] = 0.0;
    A12[61] = -0.00634920634920636*G12_0_0 + 0.00476190476190476*G12_1_0 - 0.00634920634920635*G12_2_0 + 0.00634920634920634*G12_3_0 - 0.0380952380952381*G12_4_0 + 0.00634920634920634*G12_5_0;
    A12[159] = 0.0;
    A12[142] = 0.0;
    A12[94] = 0.0;
    A12[169] = 0.0;
    A12[154] = 0.0;
    A12[106] = 0.0;
    A12[101] = 0.0;
    A12[187] = 0.0;
    A12[174] = 0.0;
    A12[216] = 0.0;
    A12[201] = 0.0;
    A12[8] = 0.0;
    A12[71] = 0.0;
    A12[37] = 0.0;
    A12[148] = 0.0;
    A12[123] = 0.0;
    A12[85] = 0.0;
    A12[66] = 0.0;
    A12[160] = 0.0;
    A12[137] = 0.0;
    A12[91] = 0.0;
    A12[82] = 0.0;
    A12[168] = 0.0;
    A12[109] = 0.0;
    A12[222] = 0.0;
    A12[184] = 0.0;
    A12[213] = 0.0;
    A12[204] = 0.0;
    A12[2] = -A12[47] - 0.0150793650793651*G12_0_1 - 0.00833333333333333*G12_1_1 + 0.0154761904761905*G12_2_1 + 0.0555555555555555*G12_3_1 + 0.0190476190476191*G12_4_1;
    A12[133] = 0.0;
    A12[68] = 0.0;
    A12[45] = -A12[61] - 0.0111111111111111*G12_0_0 - 0.00476190476190477*G12_0_1 + 0.0111111111111111*G12_1_0 + 0.00634920634920634*G12_1_1 + 0.00634920634920634*G12_2_1 + 0.0444444444444444*G12_3_0 + 0.0380952380952381*G12_3_1 - 0.0444444444444445*G12_4_0 - 0.00634920634920632*G12_4_1 - 0.00634920634920632*G12_5_1;
    A12[38] = 0.0;
    A12[143] = 0.0;
    A12[120] = 0.0;
    A12[88] = 0.0;
    A12[92] = 0.0;
    A12[179] = 0.0;
    A12[116] = 0.0;
    A12[219] = 0.0;
    A12[189] = 0.0;
    A12[207] = 0.0;
    A12[55] = 0.0;
    A12[29] = 0.0;
    A12[130] = 0.0;
    A12[73] = 0.0;
    A12[43] = 0.0;
    A12[146] = 0.0;
    A12[150] = 0.0;
    A12[183] = 0.0;
    A12[178] = 0.0;
    A12[119] = 0.0;
    A12[220] = 0.0;
    A12[197] = 0.0;
    A12[194] = 0.0;
    A12[12] = 0.0;
    A12[54] = 0.0;
    A12[24] = 0.0;
    A12[127] = 0.0;
    A12[62] = A12[47] - 0.00476190476190476*G12_0_1 + 0.00476190476190476*G12_1_1 - 0.0317460317460317*G12_3_1 + 0.0317460317460317*G12_4_1;
    A12[60] = -A12[62] - 0.0190476190476191*G12_0_0 - 0.0317460317460318*G12_0_1 + 0.00793650793650793*G12_1_0 + 0.0126984126984127*G12_2_0 + 0.0317460317460317*G12_2_1 - 0.00634920634920633*G12_3_0 + 0.0253968253968254*G12_3_1 - 0.0634920634920635*G12_4_0 - 0.0317460317460317*G12_5_0 - 0.0253968253968254*G12_5_1;
    A12[75] = A12[60] + 0.00476190476190476*G12_1_0 + 0.00476190476190477*G12_1_1 - 0.00476190476190477*G12_2_0 - 0.00476190476190476*G12_2_1 + 0.0317460317460318*G12_4_0 + 0.0317460317460317*G12_4_1 - 0.0317460317460317*G12_5_0 - 0.0317460317460317*G12_5_1;
    A12[44] = 0.0;
    A12[141] = 0.0;
    A12[95] = 0.0;
    A12[78] = -A12[80] + 0.0253968253968254*G12_0_0 - 0.0380952380952381*G12_1_0 - 0.00634920634920633*G12_2_0 + 0.0253968253968253*G12_3_0 + 0.0761904761904761*G12_4_0 + 0.0507936507936506*G12_5_0;
    A12[79] = -A12[78] + 0.0126984126984127*G12_0_1 + 0.0126984126984127*G12_1_1 - 0.0317460317460317*G12_2_1 + 0.0761904761904761*G12_3_1 + 0.0761904761904761*G12_4_1 + 0.253968253968254*G12_5_1;
    A12[50] = -A12[78] + 0.00634920634920635*G12_0_0 + 0.00634920634920634*G12_0_1 - 0.0317460317460317*G12_1_0 - 0.00634920634920634*G12_2_1 - 0.0507936507936508*G12_3_0 - 0.0761904761904761*G12_3_1 + 0.0507936507936507*G12_4_0 + 0.0253968253968253*G12_5_0 + 0.0761904761904762*G12_5_1;
    A12[172] = 0.0;
    A12[155] = 0.0;
    A12[105] = 0.0;
    A12[98] = 0.0;
    A12[180] = 0.0;
    A12[173] = 0.0;
    A12[118] = 0.0;
    A12[217] = 0.0;
    A12[200] = 0.0;
    A12[6] = 0.0;
    A12[22] = 0.0;
    A12[9] = 0.0;
    A12[147] = 0.0;
    A12[124] = 0.0;
    A12[84] = 0.0;
    A12[67] = 0.0;
    A12[161] = 0.0;
    A12[136] = 0.0;
    A12[96] = 0.0;
    A12[81] = 0.0;
    A12[167] = 0.0;
    A12[156] = 0.0;
    A12[112] = 0.0;
    A12[223] = 0.0;
    A12[185] = 0.0;
    A12[210] = 0.0;
    A12[203] = 0.0;
    A12[59] = 0.0;
    A12[17] = A12[2] + 0.0115079365079365*G12_0_1 - 0.0115079365079365*G12_1_1 - 0.00476190476190476*G12_3_1 + 0.00476190476190476*G12_4_1;
    A12[35] = -A12[17] - 0.00793650793650793*G12_0_0 + 0.00277777777777777*G12_0_1 + 0.00793650793650793*G12_1_0 - 0.000793650793650791*G12_1_1 - 0.0130952380952381*G12_2_1 + 0.00634920634920634*G12_3_0 - 0.00634920634920635*G12_4_0 - 0.0015873015873016*G12_4_1 + 0.0126984126984127*G12_5_1;
    A12[15] = -A12[17] + 0.00357142857142857*G12_0_0 + 0.00793650793650793*G12_0_1 + 0.00714285714285713*G12_1_0 - 0.00436507936507936*G12_2_0 - 0.00793650793650793*G12_2_1 + 0.00634920634920634*G12_3_0 - 0.00634920634920635*G12_3_1 + 0.00793650793650793*G12_4_0 + 0.0126984126984127*G12_5_0 + 0.00634920634920634*G12_5_1;
    A12[33] = -A12[35] - 0.0142857142857143*G12_0_0 + 0.00158730158730159*G12_1_0 + 0.0476190476190475*G12_2_0 + 0.0253968253968254*G12_3_0 + 0.0126984126984127*G12_4_0 - 0.00634920634920633*G12_5_0;
    A12[34] = -A12[33] + 0.00158730158730158*G12_0_1 + 0.00158730158730159*G12_1_1 - 0.0285714285714285*G12_2_1 - 0.0380952380952381*G12_3_1 - 0.0380952380952381*G12_4_1 - 0.0317460317460317*G12_5_1;
    A12[4] = -A12[34] - 0.00317460317460317*G12_0_0 + 0.0380952380952381*G12_0_1 + 0.00476190476190474*G12_1_0 - 0.0412698412698412*G12_2_0 - 0.0380952380952381*G12_2_1 - 0.0126984126984127*G12_3_1 - 0.00634920634920637*G12_4_0 + 0.0126984126984127*G12_5_0 + 0.0126984126984127*G12_5_1;
    A12[3] = -A12[4] + 0.0476190476190476*G12_0_1 - 0.0142857142857143*G12_1_1 + 0.00158730158730158*G12_2_1 - 0.00634920634920633*G12_3_1 + 0.0253968253968254*G12_4_1 + 0.0126984126984127*G12_5_1;
    A12[5] = -A12[3] + 0.0476190476190476*G12_0_0 + 0.00158730158730159*G12_1_0 - 0.0142857142857143*G12_2_0 - 0.00634920634920633*G12_3_0 + 0.0126984126984127*G12_4_0 + 0.0253968253968254*G12_5_0;
    A12[20] = -A12[5] + 0.0380952380952381*G12_0_0 - 0.00317460317460317*G12_0_1 - 0.0380952380952381*G12_1_0 - 0.0412698412698412*G12_1_1 + 0.00476190476190475*G12_2_1 - 0.0126984126984127*G12_3_0 + 0.0126984126984127*G12_4_0 + 0.0126984126984127*G12_4_1 - 0.00634920634920636*G12_5_1;
    A12[18] = -A12[20] + 0.00158730158730159*G12_0_0 - 0.0285714285714285*G12_1_0 + 0.00158730158730159*G12_2_0 - 0.0380952380952381*G12_3_0 - 0.0317460317460317*G12_4_0 - 0.0380952380952381*G12_5_0;
    A12[19] = -A12[18] - 0.0142857142857143*G12_0_1 + 0.0476190476190476*G12_1_1 + 0.00158730158730159*G12_2_1 + 0.0253968253968254*G12_3_1 - 0.00634920634920634*G12_4_1 + 0.0126984126984127*G12_5_1;
    A12[134] = 0.0;
    A12[69] = 0.0;
    A12[48] = -A12[50] - 0.00634920634920633*G12_0_0 - 0.0380952380952381*G12_1_0 + 0.0253968253968254*G12_2_0 + 0.0507936507936507*G12_3_0 + 0.0761904761904761*G12_4_0 + 0.0253968253968253*G12_5_0;
    A12[49] = -A12[48] - 0.00634920634920633*G12_0_1 + 0.0253968253968254*G12_1_1 - 0.0380952380952381*G12_2_1 + 0.0507936507936507*G12_3_1 + 0.0253968253968253*G12_4_1 + 0.0761904761904761*G12_5_1;
    A12[39] = 0.0;
    A12[121] = 0.0;
    A12[87] = 0.0;
    A12[162] = 0.0;
    A12[93] = 0.0;
    A12[166] = 0.0;
    A12[115] = 0.0;
    A12[224] = 0.0;
    A12[190] = 0.0;
    A12[206] = 0.0;
    A12[0] = -A12[16] - 0.0345238095238095*G12_0_0 - 0.030952380952381*G12_0_1 + 0.0345238095238095*G12_1_0 + 0.00357142857142857*G12_1_1 + 0.00357142857142857*G12_2_1 + 0.0142857142857143*G12_3_0 - 0.00476190476190476*G12_3_1 - 0.0142857142857143*G12_4_0 - 0.0190476190476191*G12_4_1 - 0.0190476190476191*G12_5_1;
    A12[58] = 0.0;
    A12[28] = 0.0;
    A12[131] = 0.0;
    A12[74] = 0.0;
    A12[40] = 0.0;
    A12[145] = 0.0;
    A12[151] = 0.0;
    A12[102] = 0.0;
    A12[177] = 0.0;
    A12[114] = 0.0;
    A12[221] = 0.0;
    A12[196] = 0.0;
    A12[209] = 0.0;
    A12[13] = 0.0;
    A12[53] = 0.0;
    A12[30] = A12[15] - 0.0115079365079365*G12_1_0 - 0.0115079365079365*G12_1_1 + 0.0115079365079365*G12_2_0 + 0.0115079365079365*G12_2_1 + 0.00476190476190477*G12_4_0 + 0.00476190476190476*G12_4_1 - 0.00476190476190476*G12_5_0 - 0.00476190476190477*G12_5_1;
    A12[23] = 0.0;
    A12[128] = 0.0;
    A12[140] = 0.0;
    A12[77] = -0.00634920634920635*G12_0_1 - 0.00634920634920636*G12_1_1 + 0.00476190476190476*G12_2_1 + 0.00634920634920636*G12_3_1 + 0.00634920634920636*G12_4_1 - 0.0380952380952381*G12_5_1;
    A12[65] = -A12[77] + 0.0253968253968254*G12_0_0 - 0.0126984126984127*G12_1_0 - 0.00634920634920635*G12_2_0 + 0.0111111111111111*G12_2_1 - 0.0444444444444444*G12_3_1 + 0.101587301587302*G12_4_0 - 0.0444444444444443*G12_4_1 + 0.0253968253968254*G12_5_0 - 0.0888888888888888*G12_5_1;
    A12[63] = -A12[65] + 0.0126984126984127*G12_0_0 - 0.0317460317460317*G12_1_0 + 0.0126984126984127*G12_2_0 + 0.0761904761904761*G12_3_0 + 0.253968253968254*G12_4_0 + 0.0761904761904761*G12_5_0;
    A12[64] = -A12[63] + 0.0253968253968254*G12_0_1 - 0.00634920634920633*G12_1_1 - 0.0380952380952381*G12_2_1 + 0.0253968253968253*G12_3_1 + 0.0507936507936507*G12_4_1 + 0.0761904761904761*G12_5_1;
    A12[171] = 0.0;
    A12[152] = 0.0;
    
    double A13[225];
    A13[108] = 0.0;
    A13[99] = 0.0;
    A13[181] = 0.0;
    A13[176] = 0.0;
    A13[117] = 0.0;
    A13[214] = 0.0;
    A13[199] = 0.0;
    A13[192] = 0.0;
    A13[7] = 0.0;
    A13[21] = 0.0;
    A13[10] = 0.0;
    A13[52] = 0.0;
    A13[26] = 0.0;
    A13[125] = 0.0;
    A13[83] = 0.0;
    A13[158] = 0.0;
    A13[135] = 0.0;
    A13[97] = 0.0;
    A13[170] = 0.0;
    A13[157] = 0.0;
    A13[111] = 0.0;
    A13[100] = 0.0;
    A13[186] = 0.0;
    A13[211] = 0.0;
    A13[202] = 0.0;
    A13[16] = -0.00357142857142857*G13_6_0 + 0.0309523809523809*G13_7_0 - 0.00357142857142856*G13_8_0 + 0.019047619047619*G13_9_0 + 0.00476190476190476*G13_10_0 + 0.019047619047619*G13_11_0;
    A13[70] = 0.0;
    A13[47] = -0.00793650793650793*G13_6_1 - 0.0126984126984127*G13_7_1 + 0.019047619047619*G13_8_1 + 0.0634920634920634*G13_9_1 + 0.0317460317460317*G13_10_1 + 0.00634920634920636*G13_11_1;
    A13[80] = A13[47] + 0.0317460317460318*G13_6_0 + 0.0206349206349206*G13_6_1 - 0.0317460317460317*G13_7_0 - 0.00634920634920636*G13_7_1 - 0.0253968253968254*G13_9_0 - 0.13968253968254*G13_9_1 + 0.0253968253968254*G13_10_0 - 0.0825396825396825*G13_10_1 - 0.158730158730159*G13_11_1;
    A13[36] = 0.0;
    A13[149] = 0.0;
    A13[122] = 0.0;
    A13[86] = 0.0;
    A13[163] = 0.0;
    A13[138] = 0.0;
    A13[90] = 0.0;
    A13[165] = 0.0;
    A13[110] = 0.0;
    A13[191] = 0.0;
    A13[212] = 0.0;
    A13[205] = 0.0;
    A13[1] = -0.00714285714285715*G13_6_0 - 0.00357142857142857*G13_7_0 + 0.00436507936507936*G13_8_0 - 0.00793650793650793*G13_9_0 - 0.00634920634920636*G13_10_0 - 0.0126984126984127*G13_11_0;
    A13[57] = 0.0;
    A13[27] = 0.0;
    A13[132] = 0.0;
    A13[46] = -A13[1] - 0.0150793650793651*G13_6_0 + 0.0154761904761905*G13_7_0 - 0.00833333333333332*G13_8_0 + 0.0555555555555555*G13_9_0 + 0.019047619047619*G13_11_0;
    A13[41] = 0.0;
    A13[144] = 0.0;
    A13[89] = 0.0;
    A13[164] = 0.0;
    A13[103] = 0.0;
    A13[113] = 0.0;
    A13[218] = 0.0;
    A13[195] = 0.0;
    A13[188] = 0.0;
    A13[208] = 0.0;
    A13[14] = 0.0;
    A13[56] = 0.0;
    A13[31] = A13[1] + 0.0115079365079365*G13_6_0 - 0.0115079365079365*G13_8_0 - 0.00476190476190476*G13_9_0 + 0.00476190476190476*G13_11_0;
    A13[129] = 0.0;
    A13[72] = 0.0;
    A13[42] = 0.0;
    A13[139] = 0.0;
    A13[76] = A13[46] - 0.00476190476190477*G13_6_0 + 0.00476190476190476*G13_8_0 - 0.0317460317460317*G13_9_0 + 0.0317460317460318*G13_11_0;
    A13[153] = 0.0;
    A13[107] = 0.0;
    A13[104] = 0.0;
    A13[182] = 0.0;
    A13[175] = 0.0;
    A13[215] = 0.0;
    A13[198] = 0.0;
    A13[193] = 0.0;
    A13[11] = 0.0;
    A13[51] = 0.0;
    A13[32] = -0.00357142857142857*G13_6_1 - 0.00357142857142857*G13_7_1 + 0.0309523809523809*G13_8_1 + 0.019047619047619*G13_9_1 + 0.019047619047619*G13_10_1 + 0.00476190476190476*G13_11_1;
    A13[25] = 0.0;
    A13[126] = 0.0;
    A13[61] = -0.00634920634920636*G13_6_0 + 0.00476190476190476*G13_7_0 - 0.00634920634920635*G13_8_0 + 0.00634920634920634*G13_9_0 - 0.0380952380952381*G13_10_0 + 0.00634920634920634*G13_11_0;
    A13[159] = 0.0;
    A13[142] = 0.0;
    A13[94] = 0.0;
    A13[169] = 0.0;
    A13[154] = 0.0;
    A13[106] = 0.0;
    A13[101] = 0.0;
    A13[187] = 0.0;
    A13[174] = 0.0;
    A13[216] = 0.0;
    A13[201] = 0.0;
    A13[8] = 0.0;
    A13[71] = 0.0;
    A13[37] = 0.0;
    A13[148] = 0.0;
    A13[123] = 0.0;
    A13[85] = 0.0;
    A13[66] = 0.0;
    A13[160] = 0.0;
    A13[137] = 0.0;
    A13[91] = 0.0;
    A13[82] = 0.0;
    A13[168] = 0.0;
    A13[109] = 0.0;
    A13[222] = 0.0;
    A13[184] = 0.0;
    A13[213] = 0.0;
    A13[204] = 0.0;
    A13[2] = -A13[47] - 0.0150793650793651*G13_6_1 - 0.00833333333333333*G13_7_1 + 0.0154761904761905*G13_8_1 + 0.0555555555555555*G13_9_1 + 0.0190476190476191*G13_10_1;
    A13[133] = 0.0;
    A13[68] = 0.0;
    A13[45] = -A13[61] - 0.0111111111111111*G13_6_0 - 0.00476190476190477*G13_6_1 + 0.0111111111111111*G13_7_0 + 0.00634920634920634*G13_7_1 + 0.00634920634920634*G13_8_1 + 0.0444444444444444*G13_9_0 + 0.0380952380952381*G13_9_1 - 0.0444444444444445*G13_10_0 - 0.00634920634920632*G13_10_1 - 0.00634920634920632*G13_11_1;
    A13[38] = 0.0;
    A13[143] = 0.0;
    A13[120] = 0.0;
    A13[88] = 0.0;
    A13[92] = 0.0;
    A13[179] = 0.0;
    A13[116] = 0.0;
    A13[219] = 0.0;
    A13[189] = 0.0;
    A13[207] = 0.0;
    A13[55] = 0.0;
    A13[29] = 0.0;
    A13[130] = 0.0;
    A13[73] = 0.0;
    A13[43] = 0.0;
    A13[146] = 0.0;
    A13[150] = 0.0;
    A13[183] = 0.0;
    A13[178] = 0.0;
    A13[119] = 0.0;
    A13[220] = 0.0;
    A13[197] = 0.0;
    A13[194] = 0.0;
    A13[12] = 0.0;
    A13[54] = 0.0;
    A13[24] = 0.0;
    A13[127] = 0.0;
    A13[62] = A13[47] - 0.00476190476190476*G13_6_1 + 0.00476190476190476*G13_7_1 - 0.0317460317460317*G13_9_1 + 0.0317460317460317*G13_10_1;
    A13[60] = -A13[62] - 0.0190476190476191*G13_6_0 - 0.0317460317460318*G13_6_1 + 0.00793650793650793*G13_7_0 + 0.0126984126984127*G13_8_0 + 0.0317460317460317*G13_8_1 - 0.00634920634920633*G13_9_0 + 0.0253968253968254*G13_9_1 - 0.0634920634920635*G13_10_0 - 0.0317460317460317*G13_11_0 - 0.0253968253968254*G13_11_1;
    A13[75] = A13[60] + 0.00476190476190476*G13_7_0 + 0.00476190476190477*G13_7_1 - 0.00476190476190477*G13_8_0 - 0.00476190476190476*G13_8_1 + 0.0317460317460318*G13_10_0 + 0.0317460317460317*G13_10_1 - 0.0317460317460317*G13_11_0 - 0.0317460317460317*G13_11_1;
    A13[44] = 0.0;
    A13[141] = 0.0;
    A13[95] = 0.0;
    A13[78] = -A13[80] + 0.0253968253968254*G13_6_0 - 0.0380952380952381*G13_7_0 - 0.00634920634920633*G13_8_0 + 0.0253968253968253*G13_9_0 + 0.0761904761904761*G13_10_0 + 0.0507936507936506*G13_11_0;
    A13[79] = -A13[78] + 0.0126984126984127*G13_6_1 + 0.0126984126984127*G13_7_1 - 0.0317460317460317*G13_8_1 + 0.0761904761904761*G13_9_1 + 0.0761904761904761*G13_10_1 + 0.253968253968254*G13_11_1;
    A13[50] = -A13[78] + 0.00634920634920635*G13_6_0 + 0.00634920634920634*G13_6_1 - 0.0317460317460317*G13_7_0 - 0.00634920634920634*G13_8_1 - 0.0507936507936508*G13_9_0 - 0.0761904761904761*G13_9_1 + 0.0507936507936507*G13_10_0 + 0.0253968253968253*G13_11_0 + 0.0761904761904762*G13_11_1;
    A13[172] = 0.0;
    A13[155] = 0.0;
    A13[105] = 0.0;
    A13[98] = 0.0;
    A13[180] = 0.0;
    A13[173] = 0.0;
    A13[118] = 0.0;
    A13[217] = 0.0;
    A13[200] = 0.0;
    A13[6] = 0.0;
    A13[22] = 0.0;
    A13[9] = 0.0;
    A13[147] = 0.0;
    A13[124] = 0.0;
    A13[84] = 0.0;
    A13[67] = 0.0;
    A13[161] = 0.0;
    A13[136] = 0.0;
    A13[96] = 0.0;
    A13[81] = 0.0;
    A13[167] = 0.0;
    A13[156] = 0.0;
    A13[112] = 0.0;
    A13[223] = 0.0;
    A13[185] = 0.0;
    A13[210] = 0.0;
    A13[203] = 0.0;
    A13[59] = 0.0;
    A13[17] = A13[2] + 0.0115079365079365*G13_6_1 - 0.0115079365079365*G13_7_1 - 0.00476190476190476*G13_9_1 + 0.00476190476190476*G13_10_1;
    A13[35] = -A13[17] - 0.00793650793650793*G13_6_0 + 0.00277777777777777*G13_6_1 + 0.00793650793650793*G13_7_0 - 0.000793650793650791*G13_7_1 - 0.0130952380952381*G13_8_1 + 0.00634920634920634*G13_9_0 - 0.00634920634920635*G13_10_0 - 0.0015873015873016*G13_10_1 + 0.0126984126984127*G13_11_1;
    A13[15] = -A13[17] + 0.00357142857142857*G13_6_0 + 0.00793650793650793*G13_6_1 + 0.00714285714285713*G13_7_0 - 0.00436507936507936*G13_8_0 - 0.00793650793650793*G13_8_1 + 0.00634920634920634*G13_9_0 - 0.00634920634920635*G13_9_1 + 0.00793650793650793*G13_10_0 + 0.0126984126984127*G13_11_0 + 0.00634920634920634*G13_11_1;
    A13[33] = -A13[35] - 0.0142857142857143*G13_6_0 + 0.00158730158730159*G13_7_0 + 0.0476190476190475*G13_8_0 + 0.0253968253968254*G13_9_0 + 0.0126984126984127*G13_10_0 - 0.00634920634920633*G13_11_0;
    A13[34] = -A13[33] + 0.00158730158730158*G13_6_1 + 0.00158730158730159*G13_7_1 - 0.0285714285714285*G13_8_1 - 0.0380952380952381*G13_9_1 - 0.0380952380952381*G13_10_1 - 0.0317460317460317*G13_11_1;
    A13[4] = -A13[34] - 0.00317460317460317*G13_6_0 + 0.0380952380952381*G13_6_1 + 0.00476190476190474*G13_7_0 - 0.0412698412698412*G13_8_0 - 0.0380952380952381*G13_8_1 - 0.0126984126984127*G13_9_1 - 0.00634920634920637*G13_10_0 + 0.0126984126984127*G13_11_0 + 0.0126984126984127*G13_11_1;
    A13[3] = -A13[4] + 0.0476190476190476*G13_6_1 - 0.0142857142857143*G13_7_1 + 0.00158730158730158*G13_8_1 - 0.00634920634920633*G13_9_1 + 0.0253968253968254*G13_10_1 + 0.0126984126984127*G13_11_1;
    A13[5] = -A13[3] + 0.0476190476190476*G13_6_0 + 0.00158730158730159*G13_7_0 - 0.0142857142857143*G13_8_0 - 0.00634920634920633*G13_9_0 + 0.0126984126984127*G13_10_0 + 0.0253968253968254*G13_11_0;
    A13[20] = -A13[5] + 0.0380952380952381*G13_6_0 - 0.00317460317460317*G13_6_1 - 0.0380952380952381*G13_7_0 - 0.0412698412698412*G13_7_1 + 0.00476190476190475*G13_8_1 - 0.0126984126984127*G13_9_0 + 0.0126984126984127*G13_10_0 + 0.0126984126984127*G13_10_1 - 0.00634920634920636*G13_11_1;
    A13[18] = -A13[20] + 0.00158730158730159*G13_6_0 - 0.0285714285714285*G13_7_0 + 0.00158730158730159*G13_8_0 - 0.0380952380952381*G13_9_0 - 0.0317460317460317*G13_10_0 - 0.0380952380952381*G13_11_0;
    A13[19] = -A13[18] - 0.0142857142857143*G13_6_1 + 0.0476190476190476*G13_7_1 + 0.00158730158730159*G13_8_1 + 0.0253968253968254*G13_9_1 - 0.00634920634920634*G13_10_1 + 0.0126984126984127*G13_11_1;
    A13[134] = 0.0;
    A13[69] = 0.0;
    A13[48] = -A13[50] - 0.00634920634920633*G13_6_0 - 0.0380952380952381*G13_7_0 + 0.0253968253968254*G13_8_0 + 0.0507936507936507*G13_9_0 + 0.0761904761904761*G13_10_0 + 0.0253968253968253*G13_11_0;
    A13[49] = -A13[48] - 0.00634920634920633*G13_6_1 + 0.0253968253968254*G13_7_1 - 0.0380952380952381*G13_8_1 + 0.0507936507936507*G13_9_1 + 0.0253968253968253*G13_10_1 + 0.0761904761904761*G13_11_1;
    A13[39] = 0.0;
    A13[121] = 0.0;
    A13[87] = 0.0;
    A13[162] = 0.0;
    A13[93] = 0.0;
    A13[166] = 0.0;
    A13[115] = 0.0;
    A13[224] = 0.0;
    A13[190] = 0.0;
    A13[206] = 0.0;
    A13[0] = -A13[16] - 0.0345238095238095*G13_6_0 - 0.030952380952381*G13_6_1 + 0.0345238095238095*G13_7_0 + 0.00357142857142857*G13_7_1 + 0.00357142857142857*G13_8_1 + 0.0142857142857143*G13_9_0 - 0.00476190476190476*G13_9_1 - 0.0142857142857143*G13_10_0 - 0.0190476190476191*G13_10_1 - 0.0190476190476191*G13_11_1;
    A13[58] = 0.0;
    A13[28] = 0.0;
    A13[131] = 0.0;
    A13[74] = 0.0;
    A13[40] = 0.0;
    A13[145] = 0.0;
    A13[151] = 0.0;
    A13[102] = 0.0;
    A13[177] = 0.0;
    A13[114] = 0.0;
    A13[221] = 0.0;
    A13[196] = 0.0;
    A13[209] = 0.0;
    A13[13] = 0.0;
    A13[53] = 0.0;
    A13[30] = A13[15] - 0.0115079365079365*G13_7_0 - 0.0115079365079365*G13_7_1 + 0.0115079365079365*G13_8_0 + 0.0115079365079365*G13_8_1 + 0.00476190476190477*G13_10_0 + 0.00476190476190476*G13_10_1 - 0.00476190476190476*G13_11_0 - 0.00476190476190477*G13_11_1;
    A13[23] = 0.0;
    A13[128] = 0.0;
    A13[140] = 0.0;
    A13[77] = -0.00634920634920635*G13_6_1 - 0.00634920634920636*G13_7_1 + 0.00476190476190476*G13_8_1 + 0.00634920634920636*G13_9_1 + 0.00634920634920636*G13_10_1 - 0.0380952380952381*G13_11_1;
    A13[65] = -A13[77] + 0.0253968253968254*G13_6_0 - 0.0126984126984127*G13_7_0 - 0.00634920634920635*G13_8_0 + 0.0111111111111111*G13_8_1 - 0.0444444444444444*G13_9_1 + 0.101587301587302*G13_10_0 - 0.0444444444444443*G13_10_1 + 0.0253968253968254*G13_11_0 - 0.0888888888888888*G13_11_1;
    A13[63] = -A13[65] + 0.0126984126984127*G13_6_0 - 0.0317460317460317*G13_7_0 + 0.0126984126984127*G13_8_0 + 0.0761904761904761*G13_9_0 + 0.253968253968254*G13_10_0 + 0.0761904761904761*G13_11_0;
    A13[64] = -A13[63] + 0.0253968253968254*G13_6_1 - 0.00634920634920633*G13_7_1 - 0.0380952380952381*G13_8_1 + 0.0253968253968253*G13_9_1 + 0.0507936507936507*G13_10_1 + 0.0761904761904761*G13_11_1;
    A13[171] = 0.0;
    A13[152] = 0.0;
    
    double A14[225];
    A14[108] = 0.0;
    A14[181] = 0.0;
    A14[117] = 0.0;
    A14[214] = 0.0;
    A14[199] = 0.0;
    A14[192] = 0.0;
    A14[7] = 0.0;
    A14[21] = 0.0;
    A14[10] = 0.0;
    A14[52] = 0.0;
    A14[35] = 0.0;
    A14[26] = 0.0;
    A14[125] = 0.0;
    A14[83] = 0.0;
    A14[60] = 0.0;
    A14[158] = -0.0126984126984127*G14_0_1 - 0.00793650793650794*G14_1_1 + 0.019047619047619*G14_2_1 + 0.0317460317460317*G14_3_1 + 0.0634920634920635*G14_4_1 + 0.00634920634920636*G14_5_1;
    A14[176] = A14[158] + 0.0317460317460318*G14_0_0 + 0.0253968253968254*G14_0_1 - 0.0317460317460317*G14_1_0 - 0.0111111111111111*G14_1_1 - 0.0253968253968254*G14_3_0 - 0.107936507936508*G14_3_1 + 0.0253968253968254*G14_4_0 - 0.114285714285714*G14_4_1 - 0.158730158730159*G14_5_1;
    A14[135] = 0.0;
    A14[97] = -0.00714285714285715*G14_0_0 - 0.00357142857142857*G14_1_0 + 0.00436507936507936*G14_2_0 - 0.00793650793650793*G14_3_0 - 0.00634920634920636*G14_4_0 - 0.0126984126984127*G14_5_0;
    A14[80] = 0.0;
    A14[170] = 0.0;
    A14[157] = -0.00634920634920636*G14_0_0 + 0.00476190476190476*G14_1_0 - 0.00634920634920635*G14_2_0 + 0.00634920634920634*G14_3_0 - 0.0380952380952381*G14_4_0 + 0.00634920634920634*G14_5_0;
    A14[186] = 0.0;
    A14[211] = 0.0;
    A14[202] = 0.0;
    A14[4] = 0.0;
    A14[16] = 0.0;
    A14[70] = 0.0;
    A14[47] = 0.0;
    A14[36] = 0.0;
    A14[149] = 0.0;
    A14[122] = 0.0;
    A14[86] = 0.0;
    A14[65] = 0.0;
    A14[163] = 0.0;
    A14[138] = 0.0;
    A14[90] = 0.0;
    A14[165] = 0.0;
    A14[110] = 0.0;
    A14[191] = 0.0;
    A14[212] = 0.0;
    A14[205] = 0.0;
    A14[1] = 0.0;
    A14[57] = 0.0;
    A14[27] = 0.0;
    A14[132] = 0.0;
    A14[46] = 0.0;
    A14[41] = 0.0;
    A14[89] = 0.0;
    A14[164] = 0.0;
    A14[103] = 0.0;
    A14[113] = -A14[158] - 0.00833333333333333*G14_0_1 - 0.0150793650793651*G14_1_1 + 0.0154761904761905*G14_2_1 + 0.019047619047619*G14_3_1 + 0.0555555555555555*G14_4_1;
    A14[111] = -A14[113] + 0.00357142857142857*G14_0_0 + 0.00793650793650793*G14_0_1 + 0.00714285714285713*G14_1_0 - 0.00436507936507936*G14_2_0 - 0.00793650793650793*G14_2_1 + 0.00634920634920634*G14_3_0 - 0.00634920634920635*G14_3_1 + 0.00793650793650793*G14_4_0 + 0.0126984126984127*G14_5_0 + 0.00634920634920634*G14_5_1;
    A14[218] = 0.0;
    A14[195] = 0.0;
    A14[188] = 0.0;
    A14[208] = 0.0;
    A14[14] = 0.0;
    A14[56] = 0.0;
    A14[31] = 0.0;
    A14[72] = 0.0;
    A14[42] = 0.0;
    A14[139] = 0.0;
    A14[76] = 0.0;
    A14[153] = 0.0;
    A14[107] = 0.0;
    A14[104] = 0.0;
    A14[182] = 0.0;
    A14[215] = 0.0;
    A14[198] = 0.0;
    A14[193] = 0.0;
    A14[20] = 0.0;
    A14[11] = 0.0;
    A14[51] = 0.0;
    A14[32] = 0.0;
    A14[25] = 0.0;
    A14[126] = A14[111] - 0.0115079365079365*G14_1_0 - 0.0115079365079365*G14_1_1 + 0.0115079365079365*G14_2_0 + 0.0115079365079365*G14_2_1 + 0.00476190476190477*G14_4_0 + 0.00476190476190476*G14_4_1 - 0.00476190476190476*G14_5_0 - 0.00476190476190477*G14_5_1;
    A14[61] = 0.0;
    A14[142] = -A14[97] - 0.0150793650793651*G14_0_0 + 0.0154761904761905*G14_1_0 - 0.00833333333333332*G14_2_0 + 0.0555555555555555*G14_3_0 + 0.019047619047619*G14_5_0;
    A14[94] = 0.0;
    A14[79] = 0.0;
    A14[169] = 0.0;
    A14[154] = 0.0;
    A14[106] = 0.0;
    A14[187] = 0.0;
    A14[174] = -A14[176] + 0.0253968253968254*G14_0_0 - 0.0380952380952381*G14_1_0 - 0.00634920634920633*G14_2_0 + 0.0253968253968253*G14_3_0 + 0.0761904761904761*G14_4_0 + 0.0507936507936506*G14_5_0;
    A14[144] = A14[174] - 0.0126984126984127*G14_0_0 - 0.00634920634920634*G14_0_1 - 0.00634920634920635*G14_1_0 + 0.0253968253968254*G14_2_0 + 0.00634920634920634*G14_2_1 + 0.101587301587301*G14_3_0 + 0.076190476190476*G14_3_1 + 0.0253968253968254*G14_4_0 - 0.0761904761904762*G14_5_1;
    A14[175] = -A14[174] + 0.0126984126984127*G14_0_1 + 0.0126984126984127*G14_1_1 - 0.0317460317460317*G14_2_1 + 0.0761904761904761*G14_3_1 + 0.0761904761904761*G14_4_1 + 0.253968253968254*G14_5_1;
    A14[159] = A14[144] + 0.00634920634920635*G14_0_0 + 0.0126984126984127*G14_0_1 - 0.00634920634920633*G14_1_0 - 0.0253968253968253*G14_1_1 + 0.00634920634920634*G14_2_1 - 0.076190476190476*G14_3_0 - 0.101587301587301*G14_3_1 + 0.0761904761904761*G14_4_0 - 0.0253968253968254*G14_5_1;
    A14[216] = 0.0;
    A14[201] = 0.0;
    A14[5] = 0.0;
    A14[15] = 0.0;
    A14[8] = 0.0;
    A14[71] = 0.0;
    A14[50] = 0.0;
    A14[37] = 0.0;
    A14[148] = 0.0;
    A14[123] = 0.0;
    A14[85] = 0.0;
    A14[66] = 0.0;
    A14[160] = -A14[159] + 0.0253968253968254*G14_0_1 - 0.00634920634920633*G14_1_1 - 0.0380952380952381*G14_2_1 + 0.0253968253968253*G14_3_1 + 0.0507936507936507*G14_4_1 + 0.0761904761904761*G14_5_1;
    A14[137] = 0.0;
    A14[91] = 0.0;
    A14[82] = 0.0;
    A14[168] = 0.0;
    A14[109] = 0.0;
    A14[222] = 0.0;
    A14[184] = 0.0;
    A14[213] = 0.0;
    A14[204] = 0.0;
    A14[2] = 0.0;
    A14[18] = 0.0;
    A14[133] = 0.0;
    A14[68] = 0.0;
    A14[45] = 0.0;
    A14[38] = 0.0;
    A14[143] = A14[158] + 0.00476190476190476*G14_0_1 - 0.00476190476190476*G14_1_1 + 0.0317460317460317*G14_3_1 - 0.0317460317460317*G14_4_1;
    A14[120] = 0.0;
    A14[88] = 0.0;
    A14[92] = 0.0;
    A14[179] = 0.0;
    A14[219] = 0.0;
    A14[189] = 0.0;
    A14[207] = 0.0;
    A14[55] = 0.0;
    A14[29] = 0.0;
    A14[73] = 0.0;
    A14[43] = 0.0;
    A14[146] = -A14[144] - 0.00634920634920633*G14_0_0 - 0.0380952380952381*G14_1_0 + 0.0253968253968254*G14_2_0 + 0.0507936507936507*G14_3_0 + 0.0761904761904761*G14_4_0 + 0.0253968253968253*G14_5_0;
    A14[75] = 0.0;
    A14[150] = 0.0;
    A14[183] = 0.0;
    A14[178] = 0.0;
    A14[119] = 0.0;
    A14[220] = 0.0;
    A14[197] = 0.0;
    A14[194] = 0.0;
    A14[19] = 0.0;
    A14[12] = 0.0;
    A14[54] = 0.0;
    A14[33] = 0.0;
    A14[24] = 0.0;
    A14[127] = A14[97] + 0.0115079365079365*G14_0_0 - 0.0115079365079365*G14_2_0 - 0.00476190476190476*G14_3_0 + 0.00476190476190476*G14_5_0;
    A14[62] = 0.0;
    A14[44] = 0.0;
    A14[141] = -A14[157] - 0.0111111111111111*G14_0_0 - 0.00476190476190477*G14_0_1 + 0.0111111111111111*G14_1_0 + 0.00634920634920634*G14_1_1 + 0.00634920634920634*G14_2_1 + 0.0444444444444444*G14_3_0 + 0.0380952380952381*G14_3_1 - 0.0444444444444445*G14_4_0 - 0.00634920634920632*G14_4_1 - 0.00634920634920632*G14_5_1;
    A14[95] = 0.0;
    A14[78] = 0.0;
    A14[172] = A14[142] - 0.00476190476190477*G14_0_0 + 0.00476190476190476*G14_2_0 - 0.0317460317460317*G14_3_0 + 0.0317460317460318*G14_5_0;
    A14[155] = 0.0;
    A14[105] = 0.0;
    A14[98] = A14[113] - 0.0115079365079365*G14_0_1 + 0.0115079365079365*G14_1_1 + 0.00476190476190476*G14_3_1 - 0.00476190476190476*G14_4_1;
    A14[180] = 0.0;
    A14[173] = -0.00634920634920635*G14_0_1 - 0.00634920634920636*G14_1_1 + 0.00476190476190476*G14_2_1 + 0.00634920634920636*G14_3_1 + 0.00634920634920636*G14_4_1 - 0.0380952380952381*G14_5_1;
    A14[118] = 0.0;
    A14[217] = 0.0;
    A14[200] = 0.0;
    A14[6] = 0.0;
    A14[22] = 0.0;
    A14[9] = 0.0;
    A14[49] = 0.0;
    A14[34] = 0.0;
    A14[147] = 0.0;
    A14[124] = 0.0;
    A14[84] = 0.0;
    A14[67] = 0.0;
    A14[161] = -A14[159] + 0.0126984126984127*G14_0_0 - 0.0317460317460317*G14_1_0 + 0.0126984126984127*G14_2_0 + 0.0761904761904761*G14_3_0 + 0.253968253968254*G14_4_0 + 0.0761904761904761*G14_5_0;
    A14[136] = 0.0;
    A14[81] = 0.0;
    A14[167] = 0.0;
    A14[156] = -A14[158] - 0.0190476190476191*G14_0_0 - 0.0317460317460318*G14_0_1 + 0.00793650793650793*G14_1_0 + 0.0126984126984127*G14_2_0 + 0.0317460317460317*G14_2_1 - 0.00634920634920633*G14_3_0 + 0.0253968253968254*G14_3_1 - 0.0634920634920635*G14_4_0 - 0.0317460317460317*G14_5_0 - 0.0253968253968254*G14_5_1;
    A14[112] = -0.00357142857142857*G14_0_0 + 0.0309523809523809*G14_1_0 - 0.00357142857142856*G14_2_0 + 0.019047619047619*G14_3_0 + 0.00476190476190476*G14_4_0 + 0.019047619047619*G14_5_0;
    A14[96] = -A14[112] - 0.0345238095238095*G14_0_0 - 0.030952380952381*G14_0_1 + 0.0345238095238095*G14_1_0 + 0.00357142857142857*G14_1_1 + 0.00357142857142857*G14_2_1 + 0.0142857142857143*G14_3_0 - 0.00476190476190476*G14_3_1 - 0.0142857142857143*G14_4_0 - 0.0190476190476191*G14_4_1 - 0.0190476190476191*G14_5_1;
    A14[223] = 0.0;
    A14[185] = 0.0;
    A14[210] = 0.0;
    A14[203] = 0.0;
    A14[3] = 0.0;
    A14[59] = 0.0;
    A14[17] = 0.0;
    A14[134] = 0.0;
    A14[69] = 0.0;
    A14[48] = 0.0;
    A14[39] = 0.0;
    A14[121] = 0.0;
    A14[87] = 0.0;
    A14[64] = 0.0;
    A14[162] = 0.0;
    A14[93] = 0.0;
    A14[166] = 0.0;
    A14[115] = -A14[127] + 0.00277777777777777*G14_0_0 - 0.00793650793650793*G14_0_1 - 0.0130952380952381*G14_1_0 - 0.000793650793650808*G14_2_0 + 0.00793650793650792*G14_2_1 + 0.00634920634920635*G14_3_1 + 0.0126984126984127*G14_4_0 - 0.00158730158730158*G14_5_0 - 0.00634920634920633*G14_5_1;
    A14[224] = 0.0;
    A14[190] = 0.0;
    A14[206] = 0.0;
    A14[0] = 0.0;
    A14[58] = 0.0;
    A14[28] = 0.0;
    A14[74] = 0.0;
    A14[40] = 0.0;
    A14[145] = -A14[144] - 0.00634920634920633*G14_0_1 + 0.0253968253968254*G14_1_1 - 0.0380952380952381*G14_2_1 + 0.0507936507936507*G14_3_1 + 0.0253968253968253*G14_4_1 + 0.0761904761904761*G14_5_1;
    A14[151] = 0.0;
    A14[102] = 0.0;
    A14[177] = 0.0;
    A14[114] = -A14[115] - 0.0142857142857143*G14_0_1 + 0.0476190476190476*G14_1_1 + 0.00158730158730159*G14_2_1 + 0.0253968253968254*G14_3_1 - 0.00634920634920634*G14_4_1 + 0.0126984126984127*G14_5_1;
    A14[99] = A14[114] + 0.00793650793650792*G14_0_0 + 0.0158730158730159*G14_0_1 - 0.00793650793650791*G14_1_0 - 0.0539682539682539*G14_1_1 + 0.00793650793650792*G14_2_1 - 0.00634920634920632*G14_3_0 - 0.038095238095238*G14_3_1 + 0.00634920634920635*G14_4_0 - 0.0317460317460317*G14_5_1;
    A14[100] = -A14[99] + 0.0476190476190476*G14_0_1 - 0.0142857142857143*G14_1_1 + 0.00158730158730158*G14_2_1 - 0.00634920634920633*G14_3_1 + 0.0253968253968254*G14_4_1 + 0.0126984126984127*G14_5_1;
    A14[129] = A14[99] - 0.0158730158730159*G14_0_0 - 0.00793650793650793*G14_0_1 - 0.00793650793650793*G14_1_0 + 0.0539682539682539*G14_2_0 + 0.00793650793650791*G14_2_1 + 0.0380952380952381*G14_3_0 + 0.00634920634920634*G14_3_1 + 0.0317460317460317*G14_4_0 - 0.00634920634920634*G14_5_1;
    A14[101] = -A14[99] + 0.0476190476190476*G14_0_0 + 0.00158730158730159*G14_1_0 - 0.0142857142857143*G14_2_0 - 0.00634920634920633*G14_3_0 + 0.0126984126984127*G14_4_0 + 0.0253968253968254*G14_5_0;
    A14[116] = -A14[114] + 0.00158730158730159*G14_0_0 - 0.0285714285714285*G14_1_0 + 0.00158730158730159*G14_2_0 - 0.0380952380952381*G14_3_0 - 0.0317460317460317*G14_4_0 - 0.0380952380952381*G14_5_0;
    A14[130] = -A14[129] + 0.00158730158730158*G14_0_1 + 0.00158730158730159*G14_1_1 - 0.0285714285714285*G14_2_1 - 0.0380952380952381*G14_3_1 - 0.0380952380952381*G14_4_1 - 0.0317460317460317*G14_5_1;
    A14[131] = -A14[129] - 0.0142857142857143*G14_0_0 + 0.00158730158730159*G14_1_0 + 0.0476190476190475*G14_2_0 + 0.0253968253968254*G14_3_0 + 0.0126984126984127*G14_4_0 - 0.00634920634920633*G14_5_0;
    A14[221] = 0.0;
    A14[196] = 0.0;
    A14[209] = 0.0;
    A14[13] = 0.0;
    A14[53] = 0.0;
    A14[30] = 0.0;
    A14[23] = 0.0;
    A14[128] = -0.00357142857142857*G14_0_1 - 0.00357142857142857*G14_1_1 + 0.0309523809523809*G14_2_1 + 0.019047619047619*G14_3_1 + 0.019047619047619*G14_4_1 + 0.00476190476190476*G14_5_1;
    A14[63] = 0.0;
    A14[140] = 0.0;
    A14[77] = 0.0;
    A14[171] = A14[156] + 0.00476190476190476*G14_1_0 + 0.00476190476190477*G14_1_1 - 0.00476190476190477*G14_2_0 - 0.00476190476190476*G14_2_1 + 0.0317460317460318*G14_4_0 + 0.0317460317460317*G14_4_1 - 0.0317460317460317*G14_5_0 - 0.0317460317460317*G14_5_1;
    A14[152] = 0.0;
    
    double A15[225];
    A15[108] = 0.0;
    A15[181] = 0.0;
    A15[117] = 0.0;
    A15[214] = 0.0;
    A15[199] = 0.0;
    A15[192] = 0.0;
    A15[7] = 0.0;
    A15[21] = 0.0;
    A15[10] = 0.0;
    A15[52] = 0.0;
    A15[35] = 0.0;
    A15[26] = 0.0;
    A15[125] = 0.0;
    A15[83] = 0.0;
    A15[60] = 0.0;
    A15[158] = -0.0126984126984127*G15_6_1 - 0.00793650793650794*G15_7_1 + 0.019047619047619*G15_8_1 + 0.0317460317460317*G15_9_1 + 0.0634920634920635*G15_10_1 + 0.00634920634920636*G15_11_1;
    A15[176] = A15[158] + 0.0317460317460318*G15_6_0 + 0.0253968253968254*G15_6_1 - 0.0317460317460317*G15_7_0 - 0.0111111111111111*G15_7_1 - 0.0253968253968254*G15_9_0 - 0.107936507936508*G15_9_1 + 0.0253968253968254*G15_10_0 - 0.114285714285714*G15_10_1 - 0.158730158730159*G15_11_1;
    A15[135] = 0.0;
    A15[97] = -0.00714285714285715*G15_6_0 - 0.00357142857142857*G15_7_0 + 0.00436507936507936*G15_8_0 - 0.00793650793650793*G15_9_0 - 0.00634920634920636*G15_10_0 - 0.0126984126984127*G15_11_0;
    A15[80] = 0.0;
    A15[170] = 0.0;
    A15[157] = -0.00634920634920636*G15_6_0 + 0.00476190476190476*G15_7_0 - 0.00634920634920635*G15_8_0 + 0.00634920634920634*G15_9_0 - 0.0380952380952381*G15_10_0 + 0.00634920634920634*G15_11_0;
    A15[186] = 0.0;
    A15[211] = 0.0;
    A15[202] = 0.0;
    A15[4] = 0.0;
    A15[16] = 0.0;
    A15[70] = 0.0;
    A15[47] = 0.0;
    A15[36] = 0.0;
    A15[149] = 0.0;
    A15[122] = 0.0;
    A15[86] = 0.0;
    A15[65] = 0.0;
    A15[163] = 0.0;
    A15[138] = 0.0;
    A15[90] = 0.0;
    A15[165] = 0.0;
    A15[110] = 0.0;
    A15[191] = 0.0;
    A15[212] = 0.0;
    A15[205] = 0.0;
    A15[1] = 0.0;
    A15[57] = 0.0;
    A15[27] = 0.0;
    A15[132] = 0.0;
    A15[46] = 0.0;
    A15[41] = 0.0;
    A15[89] = 0.0;
    A15[164] = 0.0;
    A15[103] = 0.0;
    A15[113] = -A15[158] - 0.00833333333333333*G15_6_1 - 0.0150793650793651*G15_7_1 + 0.0154761904761905*G15_8_1 + 0.019047619047619*G15_9_1 + 0.0555555555555555*G15_10_1;
    A15[111] = -A15[113] + 0.00357142857142857*G15_6_0 + 0.00793650793650793*G15_6_1 + 0.00714285714285713*G15_7_0 - 0.00436507936507936*G15_8_0 - 0.00793650793650793*G15_8_1 + 0.00634920634920634*G15_9_0 - 0.00634920634920635*G15_9_1 + 0.00793650793650793*G15_10_0 + 0.0126984126984127*G15_11_0 + 0.00634920634920634*G15_11_1;
    A15[218] = 0.0;
    A15[195] = 0.0;
    A15[188] = 0.0;
    A15[208] = 0.0;
    A15[14] = 0.0;
    A15[56] = 0.0;
    A15[31] = 0.0;
    A15[72] = 0.0;
    A15[42] = 0.0;
    A15[139] = 0.0;
    A15[76] = 0.0;
    A15[153] = 0.0;
    A15[107] = 0.0;
    A15[104] = 0.0;
    A15[182] = 0.0;
    A15[215] = 0.0;
    A15[198] = 0.0;
    A15[193] = 0.0;
    A15[20] = 0.0;
    A15[11] = 0.0;
    A15[51] = 0.0;
    A15[32] = 0.0;
    A15[25] = 0.0;
    A15[126] = A15[111] - 0.0115079365079365*G15_7_0 - 0.0115079365079365*G15_7_1 + 0.0115079365079365*G15_8_0 + 0.0115079365079365*G15_8_1 + 0.00476190476190477*G15_10_0 + 0.00476190476190476*G15_10_1 - 0.00476190476190476*G15_11_0 - 0.00476190476190477*G15_11_1;
    A15[61] = 0.0;
    A15[142] = -A15[97] - 0.0150793650793651*G15_6_0 + 0.0154761904761905*G15_7_0 - 0.00833333333333332*G15_8_0 + 0.0555555555555555*G15_9_0 + 0.019047619047619*G15_11_0;
    A15[94] = 0.0;
    A15[79] = 0.0;
    A15[169] = 0.0;
    A15[154] = 0.0;
    A15[106] = 0.0;
    A15[187] = 0.0;
    A15[174] = -A15[176] + 0.0253968253968254*G15_6_0 - 0.0380952380952381*G15_7_0 - 0.00634920634920633*G15_8_0 + 0.0253968253968253*G15_9_0 + 0.0761904761904761*G15_10_0 + 0.0507936507936506*G15_11_0;
    A15[144] = A15[174] - 0.0126984126984127*G15_6_0 - 0.00634920634920634*G15_6_1 - 0.00634920634920635*G15_7_0 + 0.0253968253968254*G15_8_0 + 0.00634920634920634*G15_8_1 + 0.101587301587301*G15_9_0 + 0.076190476190476*G15_9_1 + 0.0253968253968254*G15_10_0 - 0.0761904761904762*G15_11_1;
    A15[175] = -A15[174] + 0.0126984126984127*G15_6_1 + 0.0126984126984127*G15_7_1 - 0.0317460317460317*G15_8_1 + 0.0761904761904761*G15_9_1 + 0.0761904761904761*G15_10_1 + 0.253968253968254*G15_11_1;
    A15[159] = A15[144] + 0.00634920634920635*G15_6_0 + 0.0126984126984127*G15_6_1 - 0.00634920634920633*G15_7_0 - 0.0253968253968253*G15_7_1 + 0.00634920634920634*G15_8_1 - 0.076190476190476*G15_9_0 - 0.101587301587301*G15_9_1 + 0.0761904761904761*G15_10_0 - 0.0253968253968254*G15_11_1;
    A15[216] = 0.0;
    A15[201] = 0.0;
    A15[5] = 0.0;
    A15[15] = 0.0;
    A15[8] = 0.0;
    A15[71] = 0.0;
    A15[50] = 0.0;
    A15[37] = 0.0;
    A15[148] = 0.0;
    A15[123] = 0.0;
    A15[85] = 0.0;
    A15[66] = 0.0;
    A15[160] = -A15[159] + 0.0253968253968254*G15_6_1 - 0.00634920634920633*G15_7_1 - 0.0380952380952381*G15_8_1 + 0.0253968253968253*G15_9_1 + 0.0507936507936507*G15_10_1 + 0.0761904761904761*G15_11_1;
    A15[137] = 0.0;
    A15[91] = 0.0;
    A15[82] = 0.0;
    A15[168] = 0.0;
    A15[109] = 0.0;
    A15[222] = 0.0;
    A15[184] = 0.0;
    A15[213] = 0.0;
    A15[204] = 0.0;
    A15[2] = 0.0;
    A15[18] = 0.0;
    A15[133] = 0.0;
    A15[68] = 0.0;
    A15[45] = 0.0;
    A15[38] = 0.0;
    A15[143] = A15[158] + 0.00476190476190476*G15_6_1 - 0.00476190476190476*G15_7_1 + 0.0317460317460317*G15_9_1 - 0.0317460317460317*G15_10_1;
    A15[120] = 0.0;
    A15[88] = 0.0;
    A15[92] = 0.0;
    A15[179] = 0.0;
    A15[219] = 0.0;
    A15[189] = 0.0;
    A15[207] = 0.0;
    A15[55] = 0.0;
    A15[29] = 0.0;
    A15[73] = 0.0;
    A15[43] = 0.0;
    A15[146] = -A15[144] - 0.00634920634920633*G15_6_0 - 0.0380952380952381*G15_7_0 + 0.0253968253968254*G15_8_0 + 0.0507936507936507*G15_9_0 + 0.0761904761904761*G15_10_0 + 0.0253968253968253*G15_11_0;
    A15[75] = 0.0;
    A15[150] = 0.0;
    A15[183] = 0.0;
    A15[178] = 0.0;
    A15[119] = 0.0;
    A15[220] = 0.0;
    A15[197] = 0.0;
    A15[194] = 0.0;
    A15[19] = 0.0;
    A15[12] = 0.0;
    A15[54] = 0.0;
    A15[33] = 0.0;
    A15[24] = 0.0;
    A15[127] = A15[97] + 0.0115079365079365*G15_6_0 - 0.0115079365079365*G15_8_0 - 0.00476190476190476*G15_9_0 + 0.00476190476190476*G15_11_0;
    A15[62] = 0.0;
    A15[44] = 0.0;
    A15[141] = -A15[157] - 0.0111111111111111*G15_6_0 - 0.00476190476190477*G15_6_1 + 0.0111111111111111*G15_7_0 + 0.00634920634920634*G15_7_1 + 0.00634920634920634*G15_8_1 + 0.0444444444444444*G15_9_0 + 0.0380952380952381*G15_9_1 - 0.0444444444444445*G15_10_0 - 0.00634920634920632*G15_10_1 - 0.00634920634920632*G15_11_1;
    A15[95] = 0.0;
    A15[78] = 0.0;
    A15[172] = A15[142] - 0.00476190476190477*G15_6_0 + 0.00476190476190476*G15_8_0 - 0.0317460317460317*G15_9_0 + 0.0317460317460318*G15_11_0;
    A15[155] = 0.0;
    A15[105] = 0.0;
    A15[98] = A15[113] - 0.0115079365079365*G15_6_1 + 0.0115079365079365*G15_7_1 + 0.00476190476190476*G15_9_1 - 0.00476190476190476*G15_10_1;
    A15[180] = 0.0;
    A15[173] = -0.00634920634920635*G15_6_1 - 0.00634920634920636*G15_7_1 + 0.00476190476190476*G15_8_1 + 0.00634920634920636*G15_9_1 + 0.00634920634920636*G15_10_1 - 0.0380952380952381*G15_11_1;
    A15[118] = 0.0;
    A15[217] = 0.0;
    A15[200] = 0.0;
    A15[6] = 0.0;
    A15[22] = 0.0;
    A15[9] = 0.0;
    A15[49] = 0.0;
    A15[34] = 0.0;
    A15[147] = 0.0;
    A15[124] = 0.0;
    A15[84] = 0.0;
    A15[67] = 0.0;
    A15[161] = -A15[159] + 0.0126984126984127*G15_6_0 - 0.0317460317460317*G15_7_0 + 0.0126984126984127*G15_8_0 + 0.0761904761904761*G15_9_0 + 0.253968253968254*G15_10_0 + 0.0761904761904761*G15_11_0;
    A15[136] = 0.0;
    A15[81] = 0.0;
    A15[167] = 0.0;
    A15[156] = -A15[158] - 0.0190476190476191*G15_6_0 - 0.0317460317460318*G15_6_1 + 0.00793650793650793*G15_7_0 + 0.0126984126984127*G15_8_0 + 0.0317460317460317*G15_8_1 - 0.00634920634920633*G15_9_0 + 0.0253968253968254*G15_9_1 - 0.0634920634920635*G15_10_0 - 0.0317460317460317*G15_11_0 - 0.0253968253968254*G15_11_1;
    A15[112] = -0.00357142857142857*G15_6_0 + 0.0309523809523809*G15_7_0 - 0.00357142857142856*G15_8_0 + 0.019047619047619*G15_9_0 + 0.00476190476190476*G15_10_0 + 0.019047619047619*G15_11_0;
    A15[96] = -A15[112] - 0.0345238095238095*G15_6_0 - 0.030952380952381*G15_6_1 + 0.0345238095238095*G15_7_0 + 0.00357142857142857*G15_7_1 + 0.00357142857142857*G15_8_1 + 0.0142857142857143*G15_9_0 - 0.00476190476190476*G15_9_1 - 0.0142857142857143*G15_10_0 - 0.0190476190476191*G15_10_1 - 0.0190476190476191*G15_11_1;
    A15[223] = 0.0;
    A15[185] = 0.0;
    A15[210] = 0.0;
    A15[203] = 0.0;
    A15[3] = 0.0;
    A15[59] = 0.0;
    A15[17] = 0.0;
    A15[134] = 0.0;
    A15[69] = 0.0;
    A15[48] = 0.0;
    A15[39] = 0.0;
    A15[121] = 0.0;
    A15[87] = 0.0;
    A15[64] = 0.0;
    A15[162] = 0.0;
    A15[93] = 0.0;
    A15[166] = 0.0;
    A15[115] = -A15[127] + 0.00277777777777777*G15_6_0 - 0.00793650793650793*G15_6_1 - 0.0130952380952381*G15_7_0 - 0.000793650793650808*G15_8_0 + 0.00793650793650792*G15_8_1 + 0.00634920634920635*G15_9_1 + 0.0126984126984127*G15_10_0 - 0.00158730158730158*G15_11_0 - 0.00634920634920633*G15_11_1;
    A15[224] = 0.0;
    A15[190] = 0.0;
    A15[206] = 0.0;
    A15[0] = 0.0;
    A15[58] = 0.0;
    A15[28] = 0.0;
    A15[74] = 0.0;
    A15[40] = 0.0;
    A15[145] = -A15[144] - 0.00634920634920633*G15_6_1 + 0.0253968253968254*G15_7_1 - 0.0380952380952381*G15_8_1 + 0.0507936507936507*G15_9_1 + 0.0253968253968253*G15_10_1 + 0.0761904761904761*G15_11_1;
    A15[151] = 0.0;
    A15[102] = 0.0;
    A15[177] = 0.0;
    A15[114] = -A15[115] - 0.0142857142857143*G15_6_1 + 0.0476190476190476*G15_7_1 + 0.00158730158730159*G15_8_1 + 0.0253968253968254*G15_9_1 - 0.00634920634920634*G15_10_1 + 0.0126984126984127*G15_11_1;
    A15[99] = A15[114] + 0.00793650793650792*G15_6_0 + 0.0158730158730159*G15_6_1 - 0.00793650793650791*G15_7_0 - 0.0539682539682539*G15_7_1 + 0.00793650793650792*G15_8_1 - 0.00634920634920632*G15_9_0 - 0.038095238095238*G15_9_1 + 0.00634920634920635*G15_10_0 - 0.0317460317460317*G15_11_1;
    A15[100] = -A15[99] + 0.0476190476190476*G15_6_1 - 0.0142857142857143*G15_7_1 + 0.00158730158730158*G15_8_1 - 0.00634920634920633*G15_9_1 + 0.0253968253968254*G15_10_1 + 0.0126984126984127*G15_11_1;
    A15[129] = A15[99] - 0.0158730158730159*G15_6_0 - 0.00793650793650793*G15_6_1 - 0.00793650793650793*G15_7_0 + 0.0539682539682539*G15_8_0 + 0.00793650793650791*G15_8_1 + 0.0380952380952381*G15_9_0 + 0.00634920634920634*G15_9_1 + 0.0317460317460317*G15_10_0 - 0.00634920634920634*G15_11_1;
    A15[101] = -A15[99] + 0.0476190476190476*G15_6_0 + 0.00158730158730159*G15_7_0 - 0.0142857142857143*G15_8_0 - 0.00634920634920633*G15_9_0 + 0.0126984126984127*G15_10_0 + 0.0253968253968254*G15_11_0;
    A15[116] = -A15[114] + 0.00158730158730159*G15_6_0 - 0.0285714285714285*G15_7_0 + 0.00158730158730159*G15_8_0 - 0.0380952380952381*G15_9_0 - 0.0317460317460317*G15_10_0 - 0.0380952380952381*G15_11_0;
    A15[130] = -A15[129] + 0.00158730158730158*G15_6_1 + 0.00158730158730159*G15_7_1 - 0.0285714285714285*G15_8_1 - 0.0380952380952381*G15_9_1 - 0.0380952380952381*G15_10_1 - 0.0317460317460317*G15_11_1;
    A15[131] = -A15[129] - 0.0142857142857143*G15_6_0 + 0.00158730158730159*G15_7_0 + 0.0476190476190475*G15_8_0 + 0.0253968253968254*G15_9_0 + 0.0126984126984127*G15_10_0 - 0.00634920634920633*G15_11_0;
    A15[221] = 0.0;
    A15[196] = 0.0;
    A15[209] = 0.0;
    A15[13] = 0.0;
    A15[53] = 0.0;
    A15[30] = 0.0;
    A15[23] = 0.0;
    A15[128] = -0.00357142857142857*G15_6_1 - 0.00357142857142857*G15_7_1 + 0.0309523809523809*G15_8_1 + 0.019047619047619*G15_9_1 + 0.019047619047619*G15_10_1 + 0.00476190476190476*G15_11_1;
    A15[63] = 0.0;
    A15[140] = 0.0;
    A15[77] = 0.0;
    A15[171] = A15[156] + 0.00476190476190476*G15_7_0 + 0.00476190476190477*G15_7_1 - 0.00476190476190477*G15_8_0 - 0.00476190476190476*G15_8_1 + 0.0317460317460318*G15_10_0 + 0.0317460317460317*G15_10_1 - 0.0317460317460317*G15_11_0 - 0.0317460317460317*G15_11_1;
    A15[152] = 0.0;
    
    A[0] = A0[0] + A1[0] + A2[0] + A3[0] + A4[0] + A5[0] + A6[0] + A7[0] + A8[0] + A9[0] + A10[0] + A11[0] + A12[0] + A13[0] + A14[0] + A15[0];
    A[1] = A0[1] + A1[1] + A2[1] + A3[1] + A4[1] + A5[1] + A6[1] + A7[1] + A8[1] + A9[1] + A10[1] + A11[1] + A12[1] + A13[1] + A14[1] + A15[1];
    A[2] = A0[2] + A1[2] + A2[2] + A3[2] + A4[2] + A5[2] + A6[2] + A7[2] + A8[2] + A9[2] + A10[2] + A11[2] + A12[2] + A13[2] + A14[2] + A15[2];
    A[3] = A0[3] + A1[3] + A2[3] + A3[3] + A4[3] + A5[3] + A6[3] + A7[3] + A8[3] + A9[3] + A10[3] + A11[3] + A12[3] + A13[3] + A14[3] + A15[3];
    A[4] = A0[4] + A1[4] + A2[4] + A3[4] + A4[4] + A5[4] + A6[4] + A7[4] + A8[4] + A9[4] + A10[4] + A11[4] + A12[4] + A13[4] + A14[4] + A15[4];
    A[5] = A0[5] + A1[5] + A2[5] + A3[5] + A4[5] + A5[5] + A6[5] + A7[5] + A8[5] + A9[5] + A10[5] + A11[5] + A12[5] + A13[5] + A14[5] + A15[5];
    A[6] = A0[6] + A1[6] + A2[6] + A3[6] + A4[6] + A5[6] + A6[6] + A7[6] + A8[6] + A9[6] + A10[6] + A11[6] + A12[6] + A13[6] + A14[6] + A15[6];
    A[7] = A0[7] + A1[7] + A2[7] + A3[7] + A4[7] + A5[7] + A6[7] + A7[7] + A8[7] + A9[7] + A10[7] + A11[7] + A12[7] + A13[7] + A14[7] + A15[7];
    A[8] = A0[8] + A1[8] + A2[8] + A3[8] + A4[8] + A5[8] + A6[8] + A7[8] + A8[8] + A9[8] + A10[8] + A11[8] + A12[8] + A13[8] + A14[8] + A15[8];
    A[9] = A0[9] + A1[9] + A2[9] + A3[9] + A4[9] + A5[9] + A6[9] + A7[9] + A8[9] + A9[9] + A10[9] + A11[9] + A12[9] + A13[9] + A14[9] + A15[9];
    A[10] = A0[10] + A1[10] + A2[10] + A3[10] + A4[10] + A5[10] + A6[10] + A7[10] + A8[10] + A9[10] + A10[10] + A11[10] + A12[10] + A13[10] + A14[10] + A15[10];
    A[11] = A0[11] + A1[11] + A2[11] + A3[11] + A4[11] + A5[11] + A6[11] + A7[11] + A8[11] + A9[11] + A10[11] + A11[11] + A12[11] + A13[11] + A14[11] + A15[11];
    A[12] = A0[12] + A1[12] + A2[12] + A3[12] + A4[12] + A5[12] + A6[12] + A7[12] + A8[12] + A9[12] + A10[12] + A11[12] + A12[12] + A13[12] + A14[12] + A15[12];
    A[13] = A0[13] + A1[13] + A2[13] + A3[13] + A4[13] + A5[13] + A6[13] + A7[13] + A8[13] + A9[13] + A10[13] + A11[13] + A12[13] + A13[13] + A14[13] + A15[13];
    A[14] = A0[14] + A1[14] + A2[14] + A3[14] + A4[14] + A5[14] + A6[14] + A7[14] + A8[14] + A9[14] + A10[14] + A11[14] + A12[14] + A13[14] + A14[14] + A15[14];
    A[15] = A0[15] + A1[15] + A2[15] + A3[15] + A4[15] + A5[15] + A6[15] + A7[15] + A8[15] + A9[15] + A10[15] + A11[15] + A12[15] + A13[15] + A14[15] + A15[15];
    A[16] = A0[16] + A1[16] + A2[16] + A3[16] + A4[16] + A5[16] + A6[16] + A7[16] + A8[16] + A9[16] + A10[16] + A11[16] + A12[16] + A13[16] + A14[16] + A15[16];
    A[17] = A0[17] + A1[17] + A2[17] + A3[17] + A4[17] + A5[17] + A6[17] + A7[17] + A8[17] + A9[17] + A10[17] + A11[17] + A12[17] + A13[17] + A14[17] + A15[17];
    A[18] = A0[18] + A1[18] + A2[18] + A3[18] + A4[18] + A5[18] + A6[18] + A7[18] + A8[18] + A9[18] + A10[18] + A11[18] + A12[18] + A13[18] + A14[18] + A15[18];
    A[19] = A0[19] + A1[19] + A2[19] + A3[19] + A4[19] + A5[19] + A6[19] + A7[19] + A8[19] + A9[19] + A10[19] + A11[19] + A12[19] + A13[19] + A14[19] + A15[19];
    A[20] = A0[20] + A1[20] + A2[20] + A3[20] + A4[20] + A5[20] + A6[20] + A7[20] + A8[20] + A9[20] + A10[20] + A11[20] + A12[20] + A13[20] + A14[20] + A15[20];
    A[21] = A0[21] + A1[21] + A2[21] + A3[21] + A4[21] + A5[21] + A6[21] + A7[21] + A8[21] + A9[21] + A10[21] + A11[21] + A12[21] + A13[21] + A14[21] + A15[21];
    A[22] = A0[22] + A1[22] + A2[22] + A3[22] + A4[22] + A5[22] + A6[22] + A7[22] + A8[22] + A9[22] + A10[22] + A11[22] + A12[22] + A13[22] + A14[22] + A15[22];
    A[23] = A0[23] + A1[23] + A2[23] + A3[23] + A4[23] + A5[23] + A6[23] + A7[23] + A8[23] + A9[23] + A10[23] + A11[23] + A12[23] + A13[23] + A14[23] + A15[23];
    A[24] = A0[24] + A1[24] + A2[24] + A3[24] + A4[24] + A5[24] + A6[24] + A7[24] + A8[24] + A9[24] + A10[24] + A11[24] + A12[24] + A13[24] + A14[24] + A15[24];
    A[25] = A0[25] + A1[25] + A2[25] + A3[25] + A4[25] + A5[25] + A6[25] + A7[25] + A8[25] + A9[25] + A10[25] + A11[25] + A12[25] + A13[25] + A14[25] + A15[25];
    A[26] = A0[26] + A1[26] + A2[26] + A3[26] + A4[26] + A5[26] + A6[26] + A7[26] + A8[26] + A9[26] + A10[26] + A11[26] + A12[26] + A13[26] + A14[26] + A15[26];
    A[27] = A0[27] + A1[27] + A2[27] + A3[27] + A4[27] + A5[27] + A6[27] + A7[27] + A8[27] + A9[27] + A10[27] + A11[27] + A12[27] + A13[27] + A14[27] + A15[27];
    A[28] = A0[28] + A1[28] + A2[28] + A3[28] + A4[28] + A5[28] + A6[28] + A7[28] + A8[28] + A9[28] + A10[28] + A11[28] + A12[28] + A13[28] + A14[28] + A15[28];
    A[29] = A0[29] + A1[29] + A2[29] + A3[29] + A4[29] + A5[29] + A6[29] + A7[29] + A8[29] + A9[29] + A10[29] + A11[29] + A12[29] + A13[29] + A14[29] + A15[29];
    A[30] = A0[30] + A1[30] + A2[30] + A3[30] + A4[30] + A5[30] + A6[30] + A7[30] + A8[30] + A9[30] + A10[30] + A11[30] + A12[30] + A13[30] + A14[30] + A15[30];
    A[31] = A0[31] + A1[31] + A2[31] + A3[31] + A4[31] + A5[31] + A6[31] + A7[31] + A8[31] + A9[31] + A10[31] + A11[31] + A12[31] + A13[31] + A14[31] + A15[31];
    A[32] = A0[32] + A1[32] + A2[32] + A3[32] + A4[32] + A5[32] + A6[32] + A7[32] + A8[32] + A9[32] + A10[32] + A11[32] + A12[32] + A13[32] + A14[32] + A15[32];
    A[33] = A0[33] + A1[33] + A2[33] + A3[33] + A4[33] + A5[33] + A6[33] + A7[33] + A8[33] + A9[33] + A10[33] + A11[33] + A12[33] + A13[33] + A14[33] + A15[33];
    A[34] = A0[34] + A1[34] + A2[34] + A3[34] + A4[34] + A5[34] + A6[34] + A7[34] + A8[34] + A9[34] + A10[34] + A11[34] + A12[34] + A13[34] + A14[34] + A15[34];
    A[35] = A0[35] + A1[35] + A2[35] + A3[35] + A4[35] + A5[35] + A6[35] + A7[35] + A8[35] + A9[35] + A10[35] + A11[35] + A12[35] + A13[35] + A14[35] + A15[35];
    A[36] = A0[36] + A1[36] + A2[36] + A3[36] + A4[36] + A5[36] + A6[36] + A7[36] + A8[36] + A9[36] + A10[36] + A11[36] + A12[36] + A13[36] + A14[36] + A15[36];
    A[37] = A0[37] + A1[37] + A2[37] + A3[37] + A4[37] + A5[37] + A6[37] + A7[37] + A8[37] + A9[37] + A10[37] + A11[37] + A12[37] + A13[37] + A14[37] + A15[37];
    A[38] = A0[38] + A1[38] + A2[38] + A3[38] + A4[38] + A5[38] + A6[38] + A7[38] + A8[38] + A9[38] + A10[38] + A11[38] + A12[38] + A13[38] + A14[38] + A15[38];
    A[39] = A0[39] + A1[39] + A2[39] + A3[39] + A4[39] + A5[39] + A6[39] + A7[39] + A8[39] + A9[39] + A10[39] + A11[39] + A12[39] + A13[39] + A14[39] + A15[39];
    A[40] = A0[40] + A1[40] + A2[40] + A3[40] + A4[40] + A5[40] + A6[40] + A7[40] + A8[40] + A9[40] + A10[40] + A11[40] + A12[40] + A13[40] + A14[40] + A15[40];
    A[41] = A0[41] + A1[41] + A2[41] + A3[41] + A4[41] + A5[41] + A6[41] + A7[41] + A8[41] + A9[41] + A10[41] + A11[41] + A12[41] + A13[41] + A14[41] + A15[41];
    A[42] = A0[42] + A1[42] + A2[42] + A3[42] + A4[42] + A5[42] + A6[42] + A7[42] + A8[42] + A9[42] + A10[42] + A11[42] + A12[42] + A13[42] + A14[42] + A15[42];
    A[43] = A0[43] + A1[43] + A2[43] + A3[43] + A4[43] + A5[43] + A6[43] + A7[43] + A8[43] + A9[43] + A10[43] + A11[43] + A12[43] + A13[43] + A14[43] + A15[43];
    A[44] = A0[44] + A1[44] + A2[44] + A3[44] + A4[44] + A5[44] + A6[44] + A7[44] + A8[44] + A9[44] + A10[44] + A11[44] + A12[44] + A13[44] + A14[44] + A15[44];
    A[45] = A0[45] + A1[45] + A2[45] + A3[45] + A4[45] + A5[45] + A6[45] + A7[45] + A8[45] + A9[45] + A10[45] + A11[45] + A12[45] + A13[45] + A14[45] + A15[45];
    A[46] = A0[46] + A1[46] + A2[46] + A3[46] + A4[46] + A5[46] + A6[46] + A7[46] + A8[46] + A9[46] + A10[46] + A11[46] + A12[46] + A13[46] + A14[46] + A15[46];
    A[47] = A0[47] + A1[47] + A2[47] + A3[47] + A4[47] + A5[47] + A6[47] + A7[47] + A8[47] + A9[47] + A10[47] + A11[47] + A12[47] + A13[47] + A14[47] + A15[47];
    A[48] = A0[48] + A1[48] + A2[48] + A3[48] + A4[48] + A5[48] + A6[48] + A7[48] + A8[48] + A9[48] + A10[48] + A11[48] + A12[48] + A13[48] + A14[48] + A15[48];
    A[49] = A0[49] + A1[49] + A2[49] + A3[49] + A4[49] + A5[49] + A6[49] + A7[49] + A8[49] + A9[49] + A10[49] + A11[49] + A12[49] + A13[49] + A14[49] + A15[49];
    A[50] = A0[50] + A1[50] + A2[50] + A3[50] + A4[50] + A5[50] + A6[50] + A7[50] + A8[50] + A9[50] + A10[50] + A11[50] + A12[50] + A13[50] + A14[50] + A15[50];
    A[51] = A0[51] + A1[51] + A2[51] + A3[51] + A4[51] + A5[51] + A6[51] + A7[51] + A8[51] + A9[51] + A10[51] + A11[51] + A12[51] + A13[51] + A14[51] + A15[51];
    A[52] = A0[52] + A1[52] + A2[52] + A3[52] + A4[52] + A5[52] + A6[52] + A7[52] + A8[52] + A9[52] + A10[52] + A11[52] + A12[52] + A13[52] + A14[52] + A15[52];
    A[53] = A0[53] + A1[53] + A2[53] + A3[53] + A4[53] + A5[53] + A6[53] + A7[53] + A8[53] + A9[53] + A10[53] + A11[53] + A12[53] + A13[53] + A14[53] + A15[53];
    A[54] = A0[54] + A1[54] + A2[54] + A3[54] + A4[54] + A5[54] + A6[54] + A7[54] + A8[54] + A9[54] + A10[54] + A11[54] + A12[54] + A13[54] + A14[54] + A15[54];
    A[55] = A0[55] + A1[55] + A2[55] + A3[55] + A4[55] + A5[55] + A6[55] + A7[55] + A8[55] + A9[55] + A10[55] + A11[55] + A12[55] + A13[55] + A14[55] + A15[55];
    A[56] = A0[56] + A1[56] + A2[56] + A3[56] + A4[56] + A5[56] + A6[56] + A7[56] + A8[56] + A9[56] + A10[56] + A11[56] + A12[56] + A13[56] + A14[56] + A15[56];
    A[57] = A0[57] + A1[57] + A2[57] + A3[57] + A4[57] + A5[57] + A6[57] + A7[57] + A8[57] + A9[57] + A10[57] + A11[57] + A12[57] + A13[57] + A14[57] + A15[57];
    A[58] = A0[58] + A1[58] + A2[58] + A3[58] + A4[58] + A5[58] + A6[58] + A7[58] + A8[58] + A9[58] + A10[58] + A11[58] + A12[58] + A13[58] + A14[58] + A15[58];
    A[59] = A0[59] + A1[59] + A2[59] + A3[59] + A4[59] + A5[59] + A6[59] + A7[59] + A8[59] + A9[59] + A10[59] + A11[59] + A12[59] + A13[59] + A14[59] + A15[59];
    A[60] = A0[60] + A1[60] + A2[60] + A3[60] + A4[60] + A5[60] + A6[60] + A7[60] + A8[60] + A9[60] + A10[60] + A11[60] + A12[60] + A13[60] + A14[60] + A15[60];
    A[61] = A0[61] + A1[61] + A2[61] + A3[61] + A4[61] + A5[61] + A6[61] + A7[61] + A8[61] + A9[61] + A10[61] + A11[61] + A12[61] + A13[61] + A14[61] + A15[61];
    A[62] = A0[62] + A1[62] + A2[62] + A3[62] + A4[62] + A5[62] + A6[62] + A7[62] + A8[62] + A9[62] + A10[62] + A11[62] + A12[62] + A13[62] + A14[62] + A15[62];
    A[63] = A0[63] + A1[63] + A2[63] + A3[63] + A4[63] + A5[63] + A6[63] + A7[63] + A8[63] + A9[63] + A10[63] + A11[63] + A12[63] + A13[63] + A14[63] + A15[63];
    A[64] = A0[64] + A1[64] + A2[64] + A3[64] + A4[64] + A5[64] + A6[64] + A7[64] + A8[64] + A9[64] + A10[64] + A11[64] + A12[64] + A13[64] + A14[64] + A15[64];
    A[65] = A0[65] + A1[65] + A2[65] + A3[65] + A4[65] + A5[65] + A6[65] + A7[65] + A8[65] + A9[65] + A10[65] + A11[65] + A12[65] + A13[65] + A14[65] + A15[65];
    A[66] = A0[66] + A1[66] + A2[66] + A3[66] + A4[66] + A5[66] + A6[66] + A7[66] + A8[66] + A9[66] + A10[66] + A11[66] + A12[66] + A13[66] + A14[66] + A15[66];
    A[67] = A0[67] + A1[67] + A2[67] + A3[67] + A4[67] + A5[67] + A6[67] + A7[67] + A8[67] + A9[67] + A10[67] + A11[67] + A12[67] + A13[67] + A14[67] + A15[67];
    A[68] = A0[68] + A1[68] + A2[68] + A3[68] + A4[68] + A5[68] + A6[68] + A7[68] + A8[68] + A9[68] + A10[68] + A11[68] + A12[68] + A13[68] + A14[68] + A15[68];
    A[69] = A0[69] + A1[69] + A2[69] + A3[69] + A4[69] + A5[69] + A6[69] + A7[69] + A8[69] + A9[69] + A10[69] + A11[69] + A12[69] + A13[69] + A14[69] + A15[69];
    A[70] = A0[70] + A1[70] + A2[70] + A3[70] + A4[70] + A5[70] + A6[70] + A7[70] + A8[70] + A9[70] + A10[70] + A11[70] + A12[70] + A13[70] + A14[70] + A15[70];
    A[71] = A0[71] + A1[71] + A2[71] + A3[71] + A4[71] + A5[71] + A6[71] + A7[71] + A8[71] + A9[71] + A10[71] + A11[71] + A12[71] + A13[71] + A14[71] + A15[71];
    A[72] = A0[72] + A1[72] + A2[72] + A3[72] + A4[72] + A5[72] + A6[72] + A7[72] + A8[72] + A9[72] + A10[72] + A11[72] + A12[72] + A13[72] + A14[72] + A15[72];
    A[73] = A0[73] + A1[73] + A2[73] + A3[73] + A4[73] + A5[73] + A6[73] + A7[73] + A8[73] + A9[73] + A10[73] + A11[73] + A12[73] + A13[73] + A14[73] + A15[73];
    A[74] = A0[74] + A1[74] + A2[74] + A3[74] + A4[74] + A5[74] + A6[74] + A7[74] + A8[74] + A9[74] + A10[74] + A11[74] + A12[74] + A13[74] + A14[74] + A15[74];
    A[75] = A0[75] + A1[75] + A2[75] + A3[75] + A4[75] + A5[75] + A6[75] + A7[75] + A8[75] + A9[75] + A10[75] + A11[75] + A12[75] + A13[75] + A14[75] + A15[75];
    A[76] = A0[76] + A1[76] + A2[76] + A3[76] + A4[76] + A5[76] + A6[76] + A7[76] + A8[76] + A9[76] + A10[76] + A11[76] + A12[76] + A13[76] + A14[76] + A15[76];
    A[77] = A0[77] + A1[77] + A2[77] + A3[77] + A4[77] + A5[77] + A6[77] + A7[77] + A8[77] + A9[77] + A10[77] + A11[77] + A12[77] + A13[77] + A14[77] + A15[77];
    A[78] = A0[78] + A1[78] + A2[78] + A3[78] + A4[78] + A5[78] + A6[78] + A7[78] + A8[78] + A9[78] + A10[78] + A11[78] + A12[78] + A13[78] + A14[78] + A15[78];
    A[79] = A0[79] + A1[79] + A2[79] + A3[79] + A4[79] + A5[79] + A6[79] + A7[79] + A8[79] + A9[79] + A10[79] + A11[79] + A12[79] + A13[79] + A14[79] + A15[79];
    A[80] = A0[80] + A1[80] + A2[80] + A3[80] + A4[80] + A5[80] + A6[80] + A7[80] + A8[80] + A9[80] + A10[80] + A11[80] + A12[80] + A13[80] + A14[80] + A15[80];
    A[81] = A0[81] + A1[81] + A2[81] + A3[81] + A4[81] + A5[81] + A6[81] + A7[81] + A8[81] + A9[81] + A10[81] + A11[81] + A12[81] + A13[81] + A14[81] + A15[81];
    A[82] = A0[82] + A1[82] + A2[82] + A3[82] + A4[82] + A5[82] + A6[82] + A7[82] + A8[82] + A9[82] + A10[82] + A11[82] + A12[82] + A13[82] + A14[82] + A15[82];
    A[83] = A0[83] + A1[83] + A2[83] + A3[83] + A4[83] + A5[83] + A6[83] + A7[83] + A8[83] + A9[83] + A10[83] + A11[83] + A12[83] + A13[83] + A14[83] + A15[83];
    A[84] = A0[84] + A1[84] + A2[84] + A3[84] + A4[84] + A5[84] + A6[84] + A7[84] + A8[84] + A9[84] + A10[84] + A11[84] + A12[84] + A13[84] + A14[84] + A15[84];
    A[85] = A0[85] + A1[85] + A2[85] + A3[85] + A4[85] + A5[85] + A6[85] + A7[85] + A8[85] + A9[85] + A10[85] + A11[85] + A12[85] + A13[85] + A14[85] + A15[85];
    A[86] = A0[86] + A1[86] + A2[86] + A3[86] + A4[86] + A5[86] + A6[86] + A7[86] + A8[86] + A9[86] + A10[86] + A11[86] + A12[86] + A13[86] + A14[86] + A15[86];
    A[87] = A0[87] + A1[87] + A2[87] + A3[87] + A4[87] + A5[87] + A6[87] + A7[87] + A8[87] + A9[87] + A10[87] + A11[87] + A12[87] + A13[87] + A14[87] + A15[87];
    A[88] = A0[88] + A1[88] + A2[88] + A3[88] + A4[88] + A5[88] + A6[88] + A7[88] + A8[88] + A9[88] + A10[88] + A11[88] + A12[88] + A13[88] + A14[88] + A15[88];
    A[89] = A0[89] + A1[89] + A2[89] + A3[89] + A4[89] + A5[89] + A6[89] + A7[89] + A8[89] + A9[89] + A10[89] + A11[89] + A12[89] + A13[89] + A14[89] + A15[89];
    A[90] = A0[90] + A1[90] + A2[90] + A3[90] + A4[90] + A5[90] + A6[90] + A7[90] + A8[90] + A9[90] + A10[90] + A11[90] + A12[90] + A13[90] + A14[90] + A15[90];
    A[91] = A0[91] + A1[91] + A2[91] + A3[91] + A4[91] + A5[91] + A6[91] + A7[91] + A8[91] + A9[91] + A10[91] + A11[91] + A12[91] + A13[91] + A14[91] + A15[91];
    A[92] = A0[92] + A1[92] + A2[92] + A3[92] + A4[92] + A5[92] + A6[92] + A7[92] + A8[92] + A9[92] + A10[92] + A11[92] + A12[92] + A13[92] + A14[92] + A15[92];
    A[93] = A0[93] + A1[93] + A2[93] + A3[93] + A4[93] + A5[93] + A6[93] + A7[93] + A8[93] + A9[93] + A10[93] + A11[93] + A12[93] + A13[93] + A14[93] + A15[93];
    A[94] = A0[94] + A1[94] + A2[94] + A3[94] + A4[94] + A5[94] + A6[94] + A7[94] + A8[94] + A9[94] + A10[94] + A11[94] + A12[94] + A13[94] + A14[94] + A15[94];
    A[95] = A0[95] + A1[95] + A2[95] + A3[95] + A4[95] + A5[95] + A6[95] + A7[95] + A8[95] + A9[95] + A10[95] + A11[95] + A12[95] + A13[95] + A14[95] + A15[95];
    A[96] = A0[96] + A1[96] + A2[96] + A3[96] + A4[96] + A5[96] + A6[96] + A7[96] + A8[96] + A9[96] + A10[96] + A11[96] + A12[96] + A13[96] + A14[96] + A15[96];
    A[97] = A0[97] + A1[97] + A2[97] + A3[97] + A4[97] + A5[97] + A6[97] + A7[97] + A8[97] + A9[97] + A10[97] + A11[97] + A12[97] + A13[97] + A14[97] + A15[97];
    A[98] = A0[98] + A1[98] + A2[98] + A3[98] + A4[98] + A5[98] + A6[98] + A7[98] + A8[98] + A9[98] + A10[98] + A11[98] + A12[98] + A13[98] + A14[98] + A15[98];
    A[99] = A0[99] + A1[99] + A2[99] + A3[99] + A4[99] + A5[99] + A6[99] + A7[99] + A8[99] + A9[99] + A10[99] + A11[99] + A12[99] + A13[99] + A14[99] + A15[99];
    A[100] = A0[100] + A1[100] + A2[100] + A3[100] + A4[100] + A5[100] + A6[100] + A7[100] + A8[100] + A9[100] + A10[100] + A11[100] + A12[100] + A13[100] + A14[100] + A15[100];
    A[101] = A0[101] + A1[101] + A2[101] + A3[101] + A4[101] + A5[101] + A6[101] + A7[101] + A8[101] + A9[101] + A10[101] + A11[101] + A12[101] + A13[101] + A14[101] + A15[101];
    A[102] = A0[102] + A1[102] + A2[102] + A3[102] + A4[102] + A5[102] + A6[102] + A7[102] + A8[102] + A9[102] + A10[102] + A11[102] + A12[102] + A13[102] + A14[102] + A15[102];
    A[103] = A0[103] + A1[103] + A2[103] + A3[103] + A4[103] + A5[103] + A6[103] + A7[103] + A8[103] + A9[103] + A10[103] + A11[103] + A12[103] + A13[103] + A14[103] + A15[103];
    A[104] = A0[104] + A1[104] + A2[104] + A3[104] + A4[104] + A5[104] + A6[104] + A7[104] + A8[104] + A9[104] + A10[104] + A11[104] + A12[104] + A13[104] + A14[104] + A15[104];
    A[105] = A0[105] + A1[105] + A2[105] + A3[105] + A4[105] + A5[105] + A6[105] + A7[105] + A8[105] + A9[105] + A10[105] + A11[105] + A12[105] + A13[105] + A14[105] + A15[105];
    A[106] = A0[106] + A1[106] + A2[106] + A3[106] + A4[106] + A5[106] + A6[106] + A7[106] + A8[106] + A9[106] + A10[106] + A11[106] + A12[106] + A13[106] + A14[106] + A15[106];
    A[107] = A0[107] + A1[107] + A2[107] + A3[107] + A4[107] + A5[107] + A6[107] + A7[107] + A8[107] + A9[107] + A10[107] + A11[107] + A12[107] + A13[107] + A14[107] + A15[107];
    A[108] = A0[108] + A1[108] + A2[108] + A3[108] + A4[108] + A5[108] + A6[108] + A7[108] + A8[108] + A9[108] + A10[108] + A11[108] + A12[108] + A13[108] + A14[108] + A15[108];
    A[109] = A0[109] + A1[109] + A2[109] + A3[109] + A4[109] + A5[109] + A6[109] + A7[109] + A8[109] + A9[109] + A10[109] + A11[109] + A12[109] + A13[109] + A14[109] + A15[109];
    A[110] = A0[110] + A1[110] + A2[110] + A3[110] + A4[110] + A5[110] + A6[110] + A7[110] + A8[110] + A9[110] + A10[110] + A11[110] + A12[110] + A13[110] + A14[110] + A15[110];
    A[111] = A0[111] + A1[111] + A2[111] + A3[111] + A4[111] + A5[111] + A6[111] + A7[111] + A8[111] + A9[111] + A10[111] + A11[111] + A12[111] + A13[111] + A14[111] + A15[111];
    A[112] = A0[112] + A1[112] + A2[112] + A3[112] + A4[112] + A5[112] + A6[112] + A7[112] + A8[112] + A9[112] + A10[112] + A11[112] + A12[112] + A13[112] + A14[112] + A15[112];
    A[113] = A0[113] + A1[113] + A2[113] + A3[113] + A4[113] + A5[113] + A6[113] + A7[113] + A8[113] + A9[113] + A10[113] + A11[113] + A12[113] + A13[113] + A14[113] + A15[113];
    A[114] = A0[114] + A1[114] + A2[114] + A3[114] + A4[114] + A5[114] + A6[114] + A7[114] + A8[114] + A9[114] + A10[114] + A11[114] + A12[114] + A13[114] + A14[114] + A15[114];
    A[115] = A0[115] + A1[115] + A2[115] + A3[115] + A4[115] + A5[115] + A6[115] + A7[115] + A8[115] + A9[115] + A10[115] + A11[115] + A12[115] + A13[115] + A14[115] + A15[115];
    A[116] = A0[116] + A1[116] + A2[116] + A3[116] + A4[116] + A5[116] + A6[116] + A7[116] + A8[116] + A9[116] + A10[116] + A11[116] + A12[116] + A13[116] + A14[116] + A15[116];
    A[117] = A0[117] + A1[117] + A2[117] + A3[117] + A4[117] + A5[117] + A6[117] + A7[117] + A8[117] + A9[117] + A10[117] + A11[117] + A12[117] + A13[117] + A14[117] + A15[117];
    A[118] = A0[118] + A1[118] + A2[118] + A3[118] + A4[118] + A5[118] + A6[118] + A7[118] + A8[118] + A9[118] + A10[118] + A11[118] + A12[118] + A13[118] + A14[118] + A15[118];
    A[119] = A0[119] + A1[119] + A2[119] + A3[119] + A4[119] + A5[119] + A6[119] + A7[119] + A8[119] + A9[119] + A10[119] + A11[119] + A12[119] + A13[119] + A14[119] + A15[119];
    A[120] = A0[120] + A1[120] + A2[120] + A3[120] + A4[120] + A5[120] + A6[120] + A7[120] + A8[120] + A9[120] + A10[120] + A11[120] + A12[120] + A13[120] + A14[120] + A15[120];
    A[121] = A0[121] + A1[121] + A2[121] + A3[121] + A4[121] + A5[121] + A6[121] + A7[121] + A8[121] + A9[121] + A10[121] + A11[121] + A12[121] + A13[121] + A14[121] + A15[121];
    A[122] = A0[122] + A1[122] + A2[122] + A3[122] + A4[122] + A5[122] + A6[122] + A7[122] + A8[122] + A9[122] + A10[122] + A11[122] + A12[122] + A13[122] + A14[122] + A15[122];
    A[123] = A0[123] + A1[123] + A2[123] + A3[123] + A4[123] + A5[123] + A6[123] + A7[123] + A8[123] + A9[123] + A10[123] + A11[123] + A12[123] + A13[123] + A14[123] + A15[123];
    A[124] = A0[124] + A1[124] + A2[124] + A3[124] + A4[124] + A5[124] + A6[124] + A7[124] + A8[124] + A9[124] + A10[124] + A11[124] + A12[124] + A13[124] + A14[124] + A15[124];
    A[125] = A0[125] + A1[125] + A2[125] + A3[125] + A4[125] + A5[125] + A6[125] + A7[125] + A8[125] + A9[125] + A10[125] + A11[125] + A12[125] + A13[125] + A14[125] + A15[125];
    A[126] = A0[126] + A1[126] + A2[126] + A3[126] + A4[126] + A5[126] + A6[126] + A7[126] + A8[126] + A9[126] + A10[126] + A11[126] + A12[126] + A13[126] + A14[126] + A15[126];
    A[127] = A0[127] + A1[127] + A2[127] + A3[127] + A4[127] + A5[127] + A6[127] + A7[127] + A8[127] + A9[127] + A10[127] + A11[127] + A12[127] + A13[127] + A14[127] + A15[127];
    A[128] = A0[128] + A1[128] + A2[128] + A3[128] + A4[128] + A5[128] + A6[128] + A7[128] + A8[128] + A9[128] + A10[128] + A11[128] + A12[128] + A13[128] + A14[128] + A15[128];
    A[129] = A0[129] + A1[129] + A2[129] + A3[129] + A4[129] + A5[129] + A6[129] + A7[129] + A8[129] + A9[129] + A10[129] + A11[129] + A12[129] + A13[129] + A14[129] + A15[129];
    A[130] = A0[130] + A1[130] + A2[130] + A3[130] + A4[130] + A5[130] + A6[130] + A7[130] + A8[130] + A9[130] + A10[130] + A11[130] + A12[130] + A13[130] + A14[130] + A15[130];
    A[131] = A0[131] + A1[131] + A2[131] + A3[131] + A4[131] + A5[131] + A6[131] + A7[131] + A8[131] + A9[131] + A10[131] + A11[131] + A12[131] + A13[131] + A14[131] + A15[131];
    A[132] = A0[132] + A1[132] + A2[132] + A3[132] + A4[132] + A5[132] + A6[132] + A7[132] + A8[132] + A9[132] + A10[132] + A11[132] + A12[132] + A13[132] + A14[132] + A15[132];
    A[133] = A0[133] + A1[133] + A2[133] + A3[133] + A4[133] + A5[133] + A6[133] + A7[133] + A8[133] + A9[133] + A10[133] + A11[133] + A12[133] + A13[133] + A14[133] + A15[133];
    A[134] = A0[134] + A1[134] + A2[134] + A3[134] + A4[134] + A5[134] + A6[134] + A7[134] + A8[134] + A9[134] + A10[134] + A11[134] + A12[134] + A13[134] + A14[134] + A15[134];
    A[135] = A0[135] + A1[135] + A2[135] + A3[135] + A4[135] + A5[135] + A6[135] + A7[135] + A8[135] + A9[135] + A10[135] + A11[135] + A12[135] + A13[135] + A14[135] + A15[135];
    A[136] = A0[136] + A1[136] + A2[136] + A3[136] + A4[136] + A5[136] + A6[136] + A7[136] + A8[136] + A9[136] + A10[136] + A11[136] + A12[136] + A13[136] + A14[136] + A15[136];
    A[137] = A0[137] + A1[137] + A2[137] + A3[137] + A4[137] + A5[137] + A6[137] + A7[137] + A8[137] + A9[137] + A10[137] + A11[137] + A12[137] + A13[137] + A14[137] + A15[137];
    A[138] = A0[138] + A1[138] + A2[138] + A3[138] + A4[138] + A5[138] + A6[138] + A7[138] + A8[138] + A9[138] + A10[138] + A11[138] + A12[138] + A13[138] + A14[138] + A15[138];
    A[139] = A0[139] + A1[139] + A2[139] + A3[139] + A4[139] + A5[139] + A6[139] + A7[139] + A8[139] + A9[139] + A10[139] + A11[139] + A12[139] + A13[139] + A14[139] + A15[139];
    A[140] = A0[140] + A1[140] + A2[140] + A3[140] + A4[140] + A5[140] + A6[140] + A7[140] + A8[140] + A9[140] + A10[140] + A11[140] + A12[140] + A13[140] + A14[140] + A15[140];
    A[141] = A0[141] + A1[141] + A2[141] + A3[141] + A4[141] + A5[141] + A6[141] + A7[141] + A8[141] + A9[141] + A10[141] + A11[141] + A12[141] + A13[141] + A14[141] + A15[141];
    A[142] = A0[142] + A1[142] + A2[142] + A3[142] + A4[142] + A5[142] + A6[142] + A7[142] + A8[142] + A9[142] + A10[142] + A11[142] + A12[142] + A13[142] + A14[142] + A15[142];
    A[143] = A0[143] + A1[143] + A2[143] + A3[143] + A4[143] + A5[143] + A6[143] + A7[143] + A8[143] + A9[143] + A10[143] + A11[143] + A12[143] + A13[143] + A14[143] + A15[143];
    A[144] = A0[144] + A1[144] + A2[144] + A3[144] + A4[144] + A5[144] + A6[144] + A7[144] + A8[144] + A9[144] + A10[144] + A11[144] + A12[144] + A13[144] + A14[144] + A15[144];
    A[145] = A0[145] + A1[145] + A2[145] + A3[145] + A4[145] + A5[145] + A6[145] + A7[145] + A8[145] + A9[145] + A10[145] + A11[145] + A12[145] + A13[145] + A14[145] + A15[145];
    A[146] = A0[146] + A1[146] + A2[146] + A3[146] + A4[146] + A5[146] + A6[146] + A7[146] + A8[146] + A9[146] + A10[146] + A11[146] + A12[146] + A13[146] + A14[146] + A15[146];
    A[147] = A0[147] + A1[147] + A2[147] + A3[147] + A4[147] + A5[147] + A6[147] + A7[147] + A8[147] + A9[147] + A10[147] + A11[147] + A12[147] + A13[147] + A14[147] + A15[147];
    A[148] = A0[148] + A1[148] + A2[148] + A3[148] + A4[148] + A5[148] + A6[148] + A7[148] + A8[148] + A9[148] + A10[148] + A11[148] + A12[148] + A13[148] + A14[148] + A15[148];
    A[149] = A0[149] + A1[149] + A2[149] + A3[149] + A4[149] + A5[149] + A6[149] + A7[149] + A8[149] + A9[149] + A10[149] + A11[149] + A12[149] + A13[149] + A14[149] + A15[149];
    A[150] = A0[150] + A1[150] + A2[150] + A3[150] + A4[150] + A5[150] + A6[150] + A7[150] + A8[150] + A9[150] + A10[150] + A11[150] + A12[150] + A13[150] + A14[150] + A15[150];
    A[151] = A0[151] + A1[151] + A2[151] + A3[151] + A4[151] + A5[151] + A6[151] + A7[151] + A8[151] + A9[151] + A10[151] + A11[151] + A12[151] + A13[151] + A14[151] + A15[151];
    A[152] = A0[152] + A1[152] + A2[152] + A3[152] + A4[152] + A5[152] + A6[152] + A7[152] + A8[152] + A9[152] + A10[152] + A11[152] + A12[152] + A13[152] + A14[152] + A15[152];
    A[153] = A0[153] + A1[153] + A2[153] + A3[153] + A4[153] + A5[153] + A6[153] + A7[153] + A8[153] + A9[153] + A10[153] + A11[153] + A12[153] + A13[153] + A14[153] + A15[153];
    A[154] = A0[154] + A1[154] + A2[154] + A3[154] + A4[154] + A5[154] + A6[154] + A7[154] + A8[154] + A9[154] + A10[154] + A11[154] + A12[154] + A13[154] + A14[154] + A15[154];
    A[155] = A0[155] + A1[155] + A2[155] + A3[155] + A4[155] + A5[155] + A6[155] + A7[155] + A8[155] + A9[155] + A10[155] + A11[155] + A12[155] + A13[155] + A14[155] + A15[155];
    A[156] = A0[156] + A1[156] + A2[156] + A3[156] + A4[156] + A5[156] + A6[156] + A7[156] + A8[156] + A9[156] + A10[156] + A11[156] + A12[156] + A13[156] + A14[156] + A15[156];
    A[157] = A0[157] + A1[157] + A2[157] + A3[157] + A4[157] + A5[157] + A6[157] + A7[157] + A8[157] + A9[157] + A10[157] + A11[157] + A12[157] + A13[157] + A14[157] + A15[157];
    A[158] = A0[158] + A1[158] + A2[158] + A3[158] + A4[158] + A5[158] + A6[158] + A7[158] + A8[158] + A9[158] + A10[158] + A11[158] + A12[158] + A13[158] + A14[158] + A15[158];
    A[159] = A0[159] + A1[159] + A2[159] + A3[159] + A4[159] + A5[159] + A6[159] + A7[159] + A8[159] + A9[159] + A10[159] + A11[159] + A12[159] + A13[159] + A14[159] + A15[159];
    A[160] = A0[160] + A1[160] + A2[160] + A3[160] + A4[160] + A5[160] + A6[160] + A7[160] + A8[160] + A9[160] + A10[160] + A11[160] + A12[160] + A13[160] + A14[160] + A15[160];
    A[161] = A0[161] + A1[161] + A2[161] + A3[161] + A4[161] + A5[161] + A6[161] + A7[161] + A8[161] + A9[161] + A10[161] + A11[161] + A12[161] + A13[161] + A14[161] + A15[161];
    A[162] = A0[162] + A1[162] + A2[162] + A3[162] + A4[162] + A5[162] + A6[162] + A7[162] + A8[162] + A9[162] + A10[162] + A11[162] + A12[162] + A13[162] + A14[162] + A15[162];
    A[163] = A0[163] + A1[163] + A2[163] + A3[163] + A4[163] + A5[163] + A6[163] + A7[163] + A8[163] + A9[163] + A10[163] + A11[163] + A12[163] + A13[163] + A14[163] + A15[163];
    A[164] = A0[164] + A1[164] + A2[164] + A3[164] + A4[164] + A5[164] + A6[164] + A7[164] + A8[164] + A9[164] + A10[164] + A11[164] + A12[164] + A13[164] + A14[164] + A15[164];
    A[165] = A0[165] + A1[165] + A2[165] + A3[165] + A4[165] + A5[165] + A6[165] + A7[165] + A8[165] + A9[165] + A10[165] + A11[165] + A12[165] + A13[165] + A14[165] + A15[165];
    A[166] = A0[166] + A1[166] + A2[166] + A3[166] + A4[166] + A5[166] + A6[166] + A7[166] + A8[166] + A9[166] + A10[166] + A11[166] + A12[166] + A13[166] + A14[166] + A15[166];
    A[167] = A0[167] + A1[167] + A2[167] + A3[167] + A4[167] + A5[167] + A6[167] + A7[167] + A8[167] + A9[167] + A10[167] + A11[167] + A12[167] + A13[167] + A14[167] + A15[167];
    A[168] = A0[168] + A1[168] + A2[168] + A3[168] + A4[168] + A5[168] + A6[168] + A7[168] + A8[168] + A9[168] + A10[168] + A11[168] + A12[168] + A13[168] + A14[168] + A15[168];
    A[169] = A0[169] + A1[169] + A2[169] + A3[169] + A4[169] + A5[169] + A6[169] + A7[169] + A8[169] + A9[169] + A10[169] + A11[169] + A12[169] + A13[169] + A14[169] + A15[169];
    A[170] = A0[170] + A1[170] + A2[170] + A3[170] + A4[170] + A5[170] + A6[170] + A7[170] + A8[170] + A9[170] + A10[170] + A11[170] + A12[170] + A13[170] + A14[170] + A15[170];
    A[171] = A0[171] + A1[171] + A2[171] + A3[171] + A4[171] + A5[171] + A6[171] + A7[171] + A8[171] + A9[171] + A10[171] + A11[171] + A12[171] + A13[171] + A14[171] + A15[171];
    A[172] = A0[172] + A1[172] + A2[172] + A3[172] + A4[172] + A5[172] + A6[172] + A7[172] + A8[172] + A9[172] + A10[172] + A11[172] + A12[172] + A13[172] + A14[172] + A15[172];
    A[173] = A0[173] + A1[173] + A2[173] + A3[173] + A4[173] + A5[173] + A6[173] + A7[173] + A8[173] + A9[173] + A10[173] + A11[173] + A12[173] + A13[173] + A14[173] + A15[173];
    A[174] = A0[174] + A1[174] + A2[174] + A3[174] + A4[174] + A5[174] + A6[174] + A7[174] + A8[174] + A9[174] + A10[174] + A11[174] + A12[174] + A13[174] + A14[174] + A15[174];
    A[175] = A0[175] + A1[175] + A2[175] + A3[175] + A4[175] + A5[175] + A6[175] + A7[175] + A8[175] + A9[175] + A10[175] + A11[175] + A12[175] + A13[175] + A14[175] + A15[175];
    A[176] = A0[176] + A1[176] + A2[176] + A3[176] + A4[176] + A5[176] + A6[176] + A7[176] + A8[176] + A9[176] + A10[176] + A11[176] + A12[176] + A13[176] + A14[176] + A15[176];
    A[177] = A0[177] + A1[177] + A2[177] + A3[177] + A4[177] + A5[177] + A6[177] + A7[177] + A8[177] + A9[177] + A10[177] + A11[177] + A12[177] + A13[177] + A14[177] + A15[177];
    A[178] = A0[178] + A1[178] + A2[178] + A3[178] + A4[178] + A5[178] + A6[178] + A7[178] + A8[178] + A9[178] + A10[178] + A11[178] + A12[178] + A13[178] + A14[178] + A15[178];
    A[179] = A0[179] + A1[179] + A2[179] + A3[179] + A4[179] + A5[179] + A6[179] + A7[179] + A8[179] + A9[179] + A10[179] + A11[179] + A12[179] + A13[179] + A14[179] + A15[179];
    A[180] = A0[180] + A1[180] + A2[180] + A3[180] + A4[180] + A5[180] + A6[180] + A7[180] + A8[180] + A9[180] + A10[180] + A11[180] + A12[180] + A13[180] + A14[180] + A15[180];
    A[181] = A0[181] + A1[181] + A2[181] + A3[181] + A4[181] + A5[181] + A6[181] + A7[181] + A8[181] + A9[181] + A10[181] + A11[181] + A12[181] + A13[181] + A14[181] + A15[181];
    A[182] = A0[182] + A1[182] + A2[182] + A3[182] + A4[182] + A5[182] + A6[182] + A7[182] + A8[182] + A9[182] + A10[182] + A11[182] + A12[182] + A13[182] + A14[182] + A15[182];
    A[183] = A0[183] + A1[183] + A2[183] + A3[183] + A4[183] + A5[183] + A6[183] + A7[183] + A8[183] + A9[183] + A10[183] + A11[183] + A12[183] + A13[183] + A14[183] + A15[183];
    A[184] = A0[184] + A1[184] + A2[184] + A3[184] + A4[184] + A5[184] + A6[184] + A7[184] + A8[184] + A9[184] + A10[184] + A11[184] + A12[184] + A13[184] + A14[184] + A15[184];
    A[185] = A0[185] + A1[185] + A2[185] + A3[185] + A4[185] + A5[185] + A6[185] + A7[185] + A8[185] + A9[185] + A10[185] + A11[185] + A12[185] + A13[185] + A14[185] + A15[185];
    A[186] = A0[186] + A1[186] + A2[186] + A3[186] + A4[186] + A5[186] + A6[186] + A7[186] + A8[186] + A9[186] + A10[186] + A11[186] + A12[186] + A13[186] + A14[186] + A15[186];
    A[187] = A0[187] + A1[187] + A2[187] + A3[187] + A4[187] + A5[187] + A6[187] + A7[187] + A8[187] + A9[187] + A10[187] + A11[187] + A12[187] + A13[187] + A14[187] + A15[187];
    A[188] = A0[188] + A1[188] + A2[188] + A3[188] + A4[188] + A5[188] + A6[188] + A7[188] + A8[188] + A9[188] + A10[188] + A11[188] + A12[188] + A13[188] + A14[188] + A15[188];
    A[189] = A0[189] + A1[189] + A2[189] + A3[189] + A4[189] + A5[189] + A6[189] + A7[189] + A8[189] + A9[189] + A10[189] + A11[189] + A12[189] + A13[189] + A14[189] + A15[189];
    A[190] = A0[190] + A1[190] + A2[190] + A3[190] + A4[190] + A5[190] + A6[190] + A7[190] + A8[190] + A9[190] + A10[190] + A11[190] + A12[190] + A13[190] + A14[190] + A15[190];
    A[191] = A0[191] + A1[191] + A2[191] + A3[191] + A4[191] + A5[191] + A6[191] + A7[191] + A8[191] + A9[191] + A10[191] + A11[191] + A12[191] + A13[191] + A14[191] + A15[191];
    A[192] = A0[192] + A1[192] + A2[192] + A3[192] + A4[192] + A5[192] + A6[192] + A7[192] + A8[192] + A9[192] + A10[192] + A11[192] + A12[192] + A13[192] + A14[192] + A15[192];
    A[193] = A0[193] + A1[193] + A2[193] + A3[193] + A4[193] + A5[193] + A6[193] + A7[193] + A8[193] + A9[193] + A10[193] + A11[193] + A12[193] + A13[193] + A14[193] + A15[193];
    A[194] = A0[194] + A1[194] + A2[194] + A3[194] + A4[194] + A5[194] + A6[194] + A7[194] + A8[194] + A9[194] + A10[194] + A11[194] + A12[194] + A13[194] + A14[194] + A15[194];
    A[195] = A0[195] + A1[195] + A2[195] + A3[195] + A4[195] + A5[195] + A6[195] + A7[195] + A8[195] + A9[195] + A10[195] + A11[195] + A12[195] + A13[195] + A14[195] + A15[195];
    A[196] = A0[196] + A1[196] + A2[196] + A3[196] + A4[196] + A5[196] + A6[196] + A7[196] + A8[196] + A9[196] + A10[196] + A11[196] + A12[196] + A13[196] + A14[196] + A15[196];
    A[197] = A0[197] + A1[197] + A2[197] + A3[197] + A4[197] + A5[197] + A6[197] + A7[197] + A8[197] + A9[197] + A10[197] + A11[197] + A12[197] + A13[197] + A14[197] + A15[197];
    A[198] = A0[198] + A1[198] + A2[198] + A3[198] + A4[198] + A5[198] + A6[198] + A7[198] + A8[198] + A9[198] + A10[198] + A11[198] + A12[198] + A13[198] + A14[198] + A15[198];
    A[199] = A0[199] + A1[199] + A2[199] + A3[199] + A4[199] + A5[199] + A6[199] + A7[199] + A8[199] + A9[199] + A10[199] + A11[199] + A12[199] + A13[199] + A14[199] + A15[199];
    A[200] = A0[200] + A1[200] + A2[200] + A3[200] + A4[200] + A5[200] + A6[200] + A7[200] + A8[200] + A9[200] + A10[200] + A11[200] + A12[200] + A13[200] + A14[200] + A15[200];
    A[201] = A0[201] + A1[201] + A2[201] + A3[201] + A4[201] + A5[201] + A6[201] + A7[201] + A8[201] + A9[201] + A10[201] + A11[201] + A12[201] + A13[201] + A14[201] + A15[201];
    A[202] = A0[202] + A1[202] + A2[202] + A3[202] + A4[202] + A5[202] + A6[202] + A7[202] + A8[202] + A9[202] + A10[202] + A11[202] + A12[202] + A13[202] + A14[202] + A15[202];
    A[203] = A0[203] + A1[203] + A2[203] + A3[203] + A4[203] + A5[203] + A6[203] + A7[203] + A8[203] + A9[203] + A10[203] + A11[203] + A12[203] + A13[203] + A14[203] + A15[203];
    A[204] = A0[204] + A1[204] + A2[204] + A3[204] + A4[204] + A5[204] + A6[204] + A7[204] + A8[204] + A9[204] + A10[204] + A11[204] + A12[204] + A13[204] + A14[204] + A15[204];
    A[205] = A0[205] + A1[205] + A2[205] + A3[205] + A4[205] + A5[205] + A6[205] + A7[205] + A8[205] + A9[205] + A10[205] + A11[205] + A12[205] + A13[205] + A14[205] + A15[205];
    A[206] = A0[206] + A1[206] + A2[206] + A3[206] + A4[206] + A5[206] + A6[206] + A7[206] + A8[206] + A9[206] + A10[206] + A11[206] + A12[206] + A13[206] + A14[206] + A15[206];
    A[207] = A0[207] + A1[207] + A2[207] + A3[207] + A4[207] + A5[207] + A6[207] + A7[207] + A8[207] + A9[207] + A10[207] + A11[207] + A12[207] + A13[207] + A14[207] + A15[207];
    A[208] = A0[208] + A1[208] + A2[208] + A3[208] + A4[208] + A5[208] + A6[208] + A7[208] + A8[208] + A9[208] + A10[208] + A11[208] + A12[208] + A13[208] + A14[208] + A15[208];
    A[209] = A0[209] + A1[209] + A2[209] + A3[209] + A4[209] + A5[209] + A6[209] + A7[209] + A8[209] + A9[209] + A10[209] + A11[209] + A12[209] + A13[209] + A14[209] + A15[209];
    A[210] = A0[210] + A1[210] + A2[210] + A3[210] + A4[210] + A5[210] + A6[210] + A7[210] + A8[210] + A9[210] + A10[210] + A11[210] + A12[210] + A13[210] + A14[210] + A15[210];
    A[211] = A0[211] + A1[211] + A2[211] + A3[211] + A4[211] + A5[211] + A6[211] + A7[211] + A8[211] + A9[211] + A10[211] + A11[211] + A12[211] + A13[211] + A14[211] + A15[211];
    A[212] = A0[212] + A1[212] + A2[212] + A3[212] + A4[212] + A5[212] + A6[212] + A7[212] + A8[212] + A9[212] + A10[212] + A11[212] + A12[212] + A13[212] + A14[212] + A15[212];
    A[213] = A0[213] + A1[213] + A2[213] + A3[213] + A4[213] + A5[213] + A6[213] + A7[213] + A8[213] + A9[213] + A10[213] + A11[213] + A12[213] + A13[213] + A14[213] + A15[213];
    A[214] = A0[214] + A1[214] + A2[214] + A3[214] + A4[214] + A5[214] + A6[214] + A7[214] + A8[214] + A9[214] + A10[214] + A11[214] + A12[214] + A13[214] + A14[214] + A15[214];
    A[215] = A0[215] + A1[215] + A2[215] + A3[215] + A4[215] + A5[215] + A6[215] + A7[215] + A8[215] + A9[215] + A10[215] + A11[215] + A12[215] + A13[215] + A14[215] + A15[215];
    A[216] = A0[216] + A1[216] + A2[216] + A3[216] + A4[216] + A5[216] + A6[216] + A7[216] + A8[216] + A9[216] + A10[216] + A11[216] + A12[216] + A13[216] + A14[216] + A15[216];
    A[217] = A0[217] + A1[217] + A2[217] + A3[217] + A4[217] + A5[217] + A6[217] + A7[217] + A8[217] + A9[217] + A10[217] + A11[217] + A12[217] + A13[217] + A14[217] + A15[217];
    A[218] = A0[218] + A1[218] + A2[218] + A3[218] + A4[218] + A5[218] + A6[218] + A7[218] + A8[218] + A9[218] + A10[218] + A11[218] + A12[218] + A13[218] + A14[218] + A15[218];
    A[219] = A0[219] + A1[219] + A2[219] + A3[219] + A4[219] + A5[219] + A6[219] + A7[219] + A8[219] + A9[219] + A10[219] + A11[219] + A12[219] + A13[219] + A14[219] + A15[219];
    A[220] = A0[220] + A1[220] + A2[220] + A3[220] + A4[220] + A5[220] + A6[220] + A7[220] + A8[220] + A9[220] + A10[220] + A11[220] + A12[220] + A13[220] + A14[220] + A15[220];
    A[221] = A0[221] + A1[221] + A2[221] + A3[221] + A4[221] + A5[221] + A6[221] + A7[221] + A8[221] + A9[221] + A10[221] + A11[221] + A12[221] + A13[221] + A14[221] + A15[221];
    A[222] = A0[222] + A1[222] + A2[222] + A3[222] + A4[222] + A5[222] + A6[222] + A7[222] + A8[222] + A9[222] + A10[222] + A11[222] + A12[222] + A13[222] + A14[222] + A15[222];
    A[223] = A0[223] + A1[223] + A2[223] + A3[223] + A4[223] + A5[223] + A6[223] + A7[223] + A8[223] + A9[223] + A10[223] + A11[223] + A12[223] + A13[223] + A14[223] + A15[223];
    A[224] = A0[224] + A1[224] + A2[224] + A3[224] + A4[224] + A5[224] + A6[224] + A7[224] + A8[224] + A9[224] + A10[224] + A11[224] + A12[224] + A13[224] + A14[224] + A15[224];
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class primal_form_0: public ufc::form
{
public:

  /// Constructor
  primal_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "c7e32ba011286f8a32d117e8437de425e0aeddaf7ef7885a73c9337afc3a4403f0ad354c34ae749d774cd757a2b3b13f1c9dee3438dd32daee8a89b25ff3964c";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_finite_element_4();
        break;
      }
    case 1:
      {
        return new primal_finite_element_4();
        break;
      }
    case 2:
      {
        return new primal_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_dofmap_4();
        break;
      }
    case 1:
      {
        return new primal_dofmap_4();
        break;
      }
    case 2:
      {
        return new primal_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new primal_cell_integral_0_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class primal_form_1: public ufc::form
{
public:

  /// Constructor
  primal_form_1() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~primal_form_1()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "04d307ec6252a204d388cb0d27e76f84fd2577cad17e5bc2700f030aff43b05851157baa56962a5233f0dc0e751528b1bbbe73de0f630c0a84355ea05855551b";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_finite_element_4();
        break;
      }
    case 1:
      {
        return new primal_finite_element_4();
        break;
      }
    case 2:
      {
        return new primal_finite_element_4();
        break;
      }
    case 3:
      {
        return new primal_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new primal_dofmap_4();
        break;
      }
    case 1:
      {
        return new primal_dofmap_4();
        break;
      }
    case 2:
      {
        return new primal_dofmap_4();
        break;
      }
    case 3:
      {
        return new primal_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new primal_cell_integral_1_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/mesh/Restriction.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>

namespace primal
{

class CoefficientSpace_nu: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_nu(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_nu(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_nu(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_nu(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace_nu(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_0()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace_nu(boost::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_0()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace_nu()
  {
  }

};

class CoefficientSpace_trial: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_trial(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_trial(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_trial(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_trial(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace_trial(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace_trial(boost::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace_trial()
  {
  }

};

class Form_F_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_F_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_F_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_F_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_F_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_F_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_F_FunctionSpace_0(boost::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_F_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_trial Form_F_FunctionSpace_1;

typedef CoefficientSpace_nu Form_F_FunctionSpace_2;

class Form_F: public dolfin::Form
{
public:

  // Constructor
  Form_F(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_0());
  }

  // Constructor
  Form_F(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& trial, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->trial = trial;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_0());
  }

  // Constructor
  Form_F(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> trial, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->trial = *trial;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_0());
  }

  // Constructor
  Form_F(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_0());
  }

  // Constructor
  Form_F(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& trial, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;

    this->trial = trial;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_0());
  }

  // Constructor
  Form_F(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> trial, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;

    this->trial = *trial;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_0());
  }

  // Destructor
  ~Form_F()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "trial")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "trial";
    case 1:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_F_FunctionSpace_0 TestSpace;
  typedef Form_F_FunctionSpace_1 CoefficientSpace_trial;
  typedef Form_F_FunctionSpace_2 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner trial;
  dolfin::CoefficientAssigner nu;
};

class Form_J_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_J_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_J_FunctionSpace_0(boost::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_J_FunctionSpace_0()
  {
  }

};

class Form_J_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_J_FunctionSpace_1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_J_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_J_FunctionSpace_1(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_J_FunctionSpace_1(boost::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new primal_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new primal_dofmap_4()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_J_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_trial Form_J_FunctionSpace_2;

typedef CoefficientSpace_nu Form_J_FunctionSpace_3;

class Form_J: public dolfin::Form
{
public:

  // Constructor
  Form_J(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_1());
  }

  // Constructor
  Form_J(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& trial, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->trial = trial;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_1());
  }

  // Constructor
  Form_J(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> trial, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->trial = *trial;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_1());
  }

  // Constructor
  Form_J(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_1());
  }

  // Constructor
  Form_J(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& trial, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->trial = trial;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_1());
  }

  // Constructor
  Form_J(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> trial, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), trial(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->trial = *trial;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new primal_form_1());
  }

  // Destructor
  ~Form_J()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "trial")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "trial";
    case 1:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_J_FunctionSpace_0 TestSpace;
  typedef Form_J_FunctionSpace_1 TrialSpace;
  typedef Form_J_FunctionSpace_2 CoefficientSpace_trial;
  typedef Form_J_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner trial;
  dolfin::CoefficientAssigner nu;
};

// Class typedefs
typedef Form_J BilinearForm;
typedef Form_J JacobianForm;
typedef Form_F LinearForm;
typedef Form_F ResidualForm;
typedef Form_F::TestSpace FunctionSpace;

}

#endif
